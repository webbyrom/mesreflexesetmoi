/**
 * @preserve
 * @author    ThemePunch <info@themepunch.com>
 * @link      http://www.themepunch.com/
 * @copyright 2018 ThemePunch
 * @version 6.7.0
 */
!function(){"use strict";if(window.SR7??={},window._tpt??={},SR7.A??={},SR7.F??={},SR7.D??={},void 0!==(SR7.A.particlewave?.init??void 0))return;SR7.A.particlewave={...SR7.A.particlewave,init:e=>{let t=SR7.A.particlewave;void 0===SR7.A.particlewavecss&&(_tpt.injectCssJs(t.style,void 0,void 0,"particlewave_global_styles"),SR7.A.particlewavecss=!0),SR7.M[e].c.moduleListeners??={},SR7.M[e].c.moduleListeners.particlewave??={},t.defCursor=SR7.M[e].c.module.style.cursor,_tpt.scrollObserver.observe(SR7.M[e].c.module),SR7.F.module.listeners.init(e),t.listeners.init(e);const a=["THREE","WEBGL"];return null==t.waves&&a.push("pw_Waves"),null==t.tools&&a.push("pw_Tools"),null==t.anim&&a.push("pw_Anim"),null==t.updateShader&&a.push("pw_Shaders"),a},getModuleBasics:(e={},t)=>({u:"compare"==t?void 0:e.u??e.enable??!0}),getLayerBasics:(e={},t)=>{let a="migrate"==t;return{type:e.type??"default",s:e.s??e.speed??40,c:e.c??e.curve??25,a:e.a??e.amplitude??35,rv:e.rv??e.randomizeValue??0,scene:{kC:e.scene?.kC??e.keepCentered??!0,a:e.scene?.a??e.angle??"0deg",t:e.scene?.t??e.tilt??"10deg",sx:e.scene?.sx??e.sx??"0",sy:e.scene?.sy??e.sy??"0",sz:e.scene?.sz??e.sz??"0",dpr:e.scene?.dpr??e.dpr??1},particle:{on:e.particle?.on??e.particlesOn??!0,particle:a?e.particle?.particle??e.particle?.type??e.particle??"default":e.particle?.particle??"default",c:e.particle?.c??e.particleColor??"color",bg:e.particle?.bg??e.parbackground??"default",bgfit:e.particle?.bgfit??e.bgfit??"cover",bgpos:e.particle?.bgpos??e.bgpos??"center center",s:e.particle?.s??e.particleSize??20,gs:e.particle?.gs??e.groShr??10,g:e.particle?.g??e.gap??20,a:e.particle?.a??e.particleAmount??900},lines:{pO:e.lines?.pO??e.particleOn??!0,bF:e.lines?.bF??e.borderFilled??!1,con:e.lines?.con??e.connectionType??"off",cC:e.lines?.cC??e.customColorOn??!1,c:e.lines?.c??e.fillColor??"#ffffff",f:e.lines?.f??e.finish??"matte",o:e.lines?.o??e.linesOpacity??20,hS:e.lines?.hS??e.hexaShift??0},balance:{f:e.balance?.f??e.fade??"off",oI:e.balance?.oI??e.opacityIntensity??95},color:{c:e.color?.c??(a?_tpt.gradient.convert(e.color??"#ffffff",!0):"#ffffff"),o:e.color?.o??e.opacity??100},anim:{mov:e.anim?.mov??e.movement??"off",p:e.anim?.p??e.animPath??"ocean",pH:e.anim?.pH??e.animPathHexa??"ocean",s:e.anim?.s??e.aniMainSpeed??40},pendulum:{a:e.pendulum?.a??e.angleEnd??0,t:e.pendulum?.t??e.tiltEnd??0,x:e.pendulum?.x??e.offsetxEnd??0,y:e.pendulum?.y??e.offsetyEnd??0,z:e.pendulum?.z??e.offsetzEnd??0,r:e.pendulum?.r??e.animRoute??"rounded"},loop:{a:e.loop?.a??e.angleSpeed??-13,t:e.loop?.t??e.tiltSpeed??8,z:e.loop?.z??e.offsetzSpeed??5},interaction:{type:e.interaction?.type??e.interaction??"off",t:e.interaction?.t??e.pTilt??30,r:e.interaction?.r??e.pRotate??30,i:e.interaction?.i??e.pIntensity??50,s:e.interaction?.s??e.pSpeed??40,sh:e.interaction?.sh??e.sbshifty??20,mb:e.interaction?.mb??e.pModuleBased??!1},design:{fx:e.design?.fx??e.ppfx??"off",f:e.design?.f??e.focus??5,a:e.design?.a??e.aperture??5,maxb:e.design?.maxb??e.maxblur??10,minb:e.design?.minb??e.minblur??0,bb:e.design?.bb??e.ppbb??!0,fn:e.design?.fn??e.ppfn??80,fsc:e.design?.fsc??e.ppfsc??82,fsz:e.design?.fsz??e.ppfsz??256,fgs:e.design?.fgs??e.ppfgs??!1},wpC:e.wpC??(a?_tpt.gradient.convert(e.wp_color??"#ffffff",!0):"#ffffff"),blend:e.blend??e.blending??"normal"}},prepareLayer:async(e,a,i,n)=>{if("particlewave"===a.subtype){var{c:n}=SR7.F.getLayer(i);return new Promise((e=>{n.addOns??={},n.addOns.particlewave={},n.addOns.particlewave.canvas=SR7.WEBGL.getCanvas(),a.addOns.particlewave=SR7.A.particlewave.getLayerBasics(a.addOns.particlewave,"normalize"),t(a.addOns.particlewave).then((t=>{n.addOns.particlewave.settings=t,n.addOns.particlewave.prepared=!0,n.el.appendChild(n.addOns.particlewave.canvas.canvas),SR7.A.particlewave.waves.build(n),e()})).catch((t=>{console.log(t),e()}))}))}},toggle:(e,t)=>{let a=SR7.A.particlewave;const i=SR7.M[e];if(a.onFire)for(let t in a.onFire[e])_tpt.hop(a.onFire[e],t)&&(i.states.inViewPort?a.play(e,i.c.layers[t]):a.pause(e,i.c.layers[t],!1))},play:(e,t)=>{let a=SR7.A.particlewave;a.onFire??={},a.onFire[e]??={},a.onFire[e][t.el.id]=!0,t.addOns.particlewave.paused&&a.waves.render(t),a.waves.resize(t,t.cw,t.ch),a.tools.updateGradientTexture(t),a.fitCameraToObject(t),a.waves.render(t)},pause:(e,t,a)=>{let i=SR7.A.particlewave;t.addOns.particlewave.paused=!0,t.addOns.particlewave.frame=cancelAnimationFrame(t.addOns.particlewave.frame),a&&i?.onFire?.[e]?.[t.el.id]&&delete i.onFire[e][t.el.id]},quickPrepare:e=>{e.addOns.particlewave.destroyed=!1,e.addOns.particlewave.canvas=SR7.WEBGL.getCanvas(),e.el.appendChild(e.addOns.particlewave.canvas.canvas),SR7.A.particlewave.waves.build(e)},listeners:{init:e=>{let t=SR7.A.particlewave;t.listenersAdded?.[e]||(t.onFire??={},t.onFire[e]??={},t.listenersAdded||document.addEventListener("sr.layer.action",(function(e){""+(e.layersettings?.addOns?.particlewave??!1)!="false"&&("enterstage"==e.eventtype?(window.e=e,e.c.addOns.particlewave.destroyed&&t.quickPrepare(e.c),t.play(e.id,e.c)):"leavestage"==e.eventtype?t.pause(e.id,e.c,!0):"leftstage"==e.eventtype&&t.waves.destroy(e.c))})),t.mouseEnter=t.mouseEnter??SR7.F.module.listeners.reg(e,"mouseenter",((e,a)=>t.listeners.mouse.module.enter(e,a))),t.mouseMove=t.mouseMove??SR7.F.module.listeners.reg(e,"mousemove",((e,a)=>t.listeners.mouse.module.move(e,a))),t.mouseLeave=t.mouseLeave??SR7.F.module.listeners.reg(e,"mouseleave",((e,a)=>t.listeners.mouse.module.leave(e,a))),t.listenersAdded??={},t.listenersAdded[e]=!0)},mouse:{module:{enter:(e,t)=>{SR7.A.particlewave.listeners.mouse.module.default(e,t,"enter")},move:(e,t)=>{SR7.A.particlewave.listeners.mouse.module.default(e,t,"move")},leave:(e,t)=>{SR7.A.particlewave.listeners.mouse.module.default(e,t,"leave")},default:(e,t,a)=>{const i=SR7.M[e];i.c.addOns??={},i.c.addOns.particlewave??={},i.c.addOns.particlewave.mouse??={};const n=i.c.addOns.particlewave;for(var e in n.mouse.type=a,SR7.M){const i=SR7.M[e];if(i.states.inViewPort)for(var s in i.c.layers){if(!i.c.layers[s].addOns?.particlewave)continue;const e=i.c.layers[s].addOns.particlewave;if(!e?.settings?.interaction.mb)continue;let n=t.clientX/i.dims.module.w*i.c.layers[s].cw,r=t.clientY/i.dims.module.h*i.c.layers[s].ch;SR7.A.particlewave.listeners.mouse[a]({layerX:n,layerY:r,clientX:n,clientY:r},i.c.layers[s],!0)}}}},enter:(e,t,a)=>{let i=t.addOns.particlewave;var n=i.canvas.canvas.getBoundingClientRect();i.mouseX=(a?e.clientX:e.clientX-n.top)/n.width,i.mouseY=(a?e.clientY:e.clientY-n.left)/n.height,_tpt.gsap.to(i,{duration:2,lerp:i.settings.lerp})},leave:(e,t)=>{let a=t.addOns.particlewave;a.mouseX=.5,a.mouseY=.5,_tpt.gsap.to(a,{duration:0,lerp:.001,overwrite:!0})},move:(e,t,a)=>{let i=t.addOns.particlewave;var n=i.canvas.canvas.getBoundingClientRect();i.mouseX=(a?e.clientX:e.clientX-n.top)/n.width,i.mouseY=(a?e.clientY:e.clientY-n.left)/n.height},follow:e=>{e.pFrame&&(e.pFrame=window.cancelAnimationFrame(e.pFrame));const{beta:t,gamma:a}=e.pEvent;let i=a,n=t-60;const s=Math.abs(e.orientationX-i)>1||Math.abs(e.orientationY-n)>1;e.orientationX=i,e.orientationY=n,s&&(_tpt.winW>_tpt.winH&&([i,n]=[n,i]),e.px=i,e.py=n)},applyfollow:e=>{if("mousefollow"!==e.settings.interaction.type)return;const t=e.settings,a=(e,t,a)=>e+(t-e)*a;if(_tpt.is_mobile){e.tx=a(e.tx,e.px,e.lerp),e.ty=a(e.ty,e.py,e.lerp);const i=t.interaction.i*Math.PI/180;e.group.rotation.x=-e.ty*i,e.group.rotation.z=e.tx*i}else e.targetX=a(e.targetX,e.mouseX,e.lerp),e.targetY=a(e.targetY,e.mouseY,e.lerp),e.group.rotation.z=t.interaction.t*(e.targetX-.5),e.group.rotation.x=t.interaction.r*(e.targetY-.5)}}},fitCameraToObject:e=>{let t=e.addOns?.particlewave??!1;if(t){let a=SR7.A.particlewave,i=Math.round(e.cw??0),n=Math.round(e.ch??0);t.lastDim={width:i,height:n},a.waves.resize(e,i,n),t.settings.isGradient&&a.tools.updateGradientTexture(e),a.waves.initPP(e),t.paused=!1,cancelAnimationFrame(t.frame),t.frame=requestAnimationFrame(t.bindedRender)}},setSceneForHexa:e=>{let t=e.settings;e.scene.rotation.y=180*Math.PI/180,e.scene.rotation.z=t.scene.a*Math.PI/180,e.scene.rotation.x=(t.scene.t+16)*Math.PI/180,e.camera.position.x=t.scene.sx,e.camera.position.y=t.scene.sx,e.camera.position.z=t.scene.sz+27,t.scene.kC&&e.camera.lookAt(0,"path"===t.anim.mov?-20:0,0)},adjustScene:t=>{let a=t.settings;t.scene.rotation.z=a.scene.a*Math.PI/180,t.scene.rotation.x=a.scene.t*Math.PI/180,t.camera.position.x=a.scene.sx,t.camera.position.y=a.scene.sy,t.camera.position.z=e(a.scene.sz)+22,a.scene.kC&&t.camera.lookAt(0,0,0)}};let e=e=>parseFloat(e),t=async t=>(t.numStops=0,t.gradientStart=new THREE.Vector2,t.gradientEnd=new THREE.Vector2,t.particle.g=e(t.particle.g)/10,t.particle.s=e(t.particle.s)/100,t.particle.a="hexa"===t.lines.con?900:t.particle.a,t.particle.a=Math.floor(Math.sqrt(e(t.particle.a))),"path"===t.anim.mov||"loop"===t.anim.mov?(t.scene.a=0,t.scene.t=10,t.scene.sx=0,t.scene.sy=0,t.scene.sz=0,t.scene.kC=!0):(t.scene.a=e(t.scene.a),t.scene.t=e(t.scene.t),t.scene.sx=e(t.scene.sx),t.scene.sy=e(t.scene.sy),t.scene.sz=e(t.scene.sz)),"keep"==t.particle.c?t.lines.cC=!0:"image"==t.particle.c&&(t.wpC="#ffffff",t.lines.c="#ffffff",t.lines.cC=!1),t.scene.a="hexa"===t.lines.con?Math.min(90,Math.max(-90,t.scene.a)):t.scene.a,t.rv=e(t.rv)/2,t.lines.o=e(t.lines.o)/100,t.lines.hS=e(t.lines.hS),t.balance.oI=e(t.balance.oI),t.anim.s=e(t.anim.s),t.pendulum.a=e(t.pendulum.a),t.pendulum.t=e(t.pendulum.t),t.pendulum.x=e(t.pendulum.x),t.pendulum.y=e(t.pendulum.y),t.pendulum.z=e(t.pendulum.z),t.loop.a=e(t.loop.a),t.loop.t=e(t.loop.t),t.loop.z=e(t.loop.z),t.particle.particle="default"===t.particle.particle?SR7.E.resources.pwURL+"public/assets/par.svg":t.particle.particle,t.particle.bg="default"===t.particle.bg?SR7.E.resources.pwURL+"public/assets/img.png":t.particle.bg,t.svg=-1!==t.particle.particle.indexOf(".svg"),t.wpC_ori=t.wpC,t.wpC=_tpt.gradient.process(t.wpC),void 0===t.clock&&(t.clock=new THREE.Clock),t.interaction.sh=-e(t.interaction.sh),t.scene.dpr=e(t.scene.dpr),t.s=e(t.s)/20,t.particle.g=e(t.particle.g),"hexa"==t.lines.con?(t.c=e(t.c)/5*2,t.a=e(t.a)/10):(t.c=e(t.c)/5*t.particle.g,t.a=e(t.a)/20*t.particle.g),t.particle.gs=e(t.particle.gs)/100,t.design.f=e(t.design.f),t.design.a=e(t.design.a),t.design.maxb=.001*e(t.design.maxb),t.design.minb=.001*e(t.design.minb),t.color=_tpt.parseColor(t.lines.c,!0),t.color_par=_tpt.parseColor(t.wpC_ori.string,!0),t.interaction.t=_tpt.DEG2RAD*e(t.interaction.t),t.interaction.r=_tpt.DEG2RAD*e(t.interaction.r),t.interaction.i=e(t.interaction.i)/50,t.lerp=e(t.interaction.s)/200,t.canvastemp=document.createElement("canvas"),t.ctxtemp=t.canvastemp.getContext("2d"),t.isGradient="solid"!==(t.wpC_ori?.type??"solid"),("image"===t.particle.c||t.isGradient)&&(t.bg??={},t.bg.canvas=document.createElement("canvas"),t.bg.texture=new THREE.CanvasTexture(t.bg.canvas),t.bg.ctx=t.bg.canvas.getContext("2d"),(t.particle.c="image")&&await _tpt.loadSingleImage(t.particle.bg).then((e=>{let a=e.image,{naturalHeight:i,naturalWidth:n}=a;var s,r,l,c,o=n/i,p=Math.max(n,i);"cover"===t.particle.bgfit||"contain"===t.bg.fit?(t.bg.canvas.width=p,t.bg.canvas.height=p):(t.bg.canvas.width=n,t.bg.canvas.height=i),t.bg.ctx.scale(-1,1),"cover"===t.particle.bgfit?(c=n>i?p*o:p,l=n>i?p:p*o,s=-1!==t.particle.bgpos.indexOf("left")?0:-1!==t.particle.bgpos.indexOf("right")?n>i?p-p*o:0:n>i?-(p*o-p)/2:0,r=-1!==t.particle.bgpos.indexOf("top")?0:-1!==t.particle.bgpos.indexOf("bottom")?n>i?0:p-p/o:n>i?0:(p-p/o)/2,t.bg.ctx.drawImage(a,0,0,n,i,-(p-s),r,c,l)):"contain"===t.bg.fit?(c=n,l=i,s=n>i?0:(p-n)/2,r=n>i?(p-n)/2:0,t.bg.ctx.drawImage(a,0,0,n,i,-(p-s),r,c,l)):t.bg.ctx.drawImage(a,-n,0,n,i),t.bg.texture.needsUpdate=!0})).catch((e=>{console.log(e)})),t.particle.c="image"),-1!==t.particle.particle.indexOf(".svg")?(t.isSVG=!0,await _tpt.loadSVG(t.particle.particle).then((e=>{if(null!==e){const a=100*t.particle.s*window.devicePixelRatio*(t.particle.gs+1);let i=e.getElementsByTagName("svg")[0];for(null!=i&&null!=i||(i=e);i.getElementsByTagName("svg").length>0;)i=i.getElementsByTagName("svg")[0];let n=parseFloat(i.getAttribute("width"))||a,s=parseFloat(i.getAttribute("height"))||a;i.setAttribute("width",n),i.setAttribute("height",s);const r=isFinite(n/s)&&n/s||1;n=r>=1?a:a*r,s=r>=1?a/r:a;let l=new Image;l.crossOrigin="Anonymous",l.src="data:image/svg+xml;base64,"+btoa((new XMLSerializer).serializeToString(i)),l.onload=function(){SR7.A.particlewave.tools.particleOnCanvas(n,s,l,t.ctxtemp)}}})).catch((e=>{console.log(e)}))):_tpt.isImageURL(t.particle.particle)&&await _tpt.loadSingleImage(t.particle.particle).then((e=>{let a,i,n=e.image;const s=100*t.particle.s*window.devicePixelRatio*(t.particle.gs+1),r=n.naturalWidthw/n.naturalHeight;isNaN(r)||0===r||!isFinite(r)?a=i=s:(a=r>=1?s:s*r,i=r>=1?s/r:s),SR7.A.particlewave.tools.particleOnCanvas(a,i,n,t.ctxtemp)})).catch((e=>{console.log(e)})),t);_tpt.R??={},_tpt.R.particlewave=_tpt.extend?_tpt.extend(_tpt.R.particlewave,{status:2,version:"1.0"}):{status:2,version:"1.0"},window.dispatchEvent(new CustomEvent("SR7ParticleWaveReady"))}();
!function(){"use strict";window.SR7??={},window._tpt??={},SR7.A??={},SR7.F??={},SR7.D??={},void 0===(SR7.A.particlewave?.anim??void 0)&&(SR7.A.particlewave={...SR7.A.particlewave,anim:{selector:a=>{let t=a.settings;var e=a.material.userData.u_time.value;"off"!=t.anim.mov&&("path"==t.anim.mov&&"hexa"!=t.lines.con&&SR7.A.particlewave.anim.path(a,e),"path"==t.anim.mov&&"hexa"===t.lines.con&&SR7.A.particlewave.anim.pathHexa(a,e),"pendulum"==t.anim.mov&&SR7.A.particlewave.anim.pendulum(a,e),"loop"==t.anim.mov&&SR7.A.particlewave.anim.loop(a))},path:(a,t)=>{let e=a.settings;switch(e.anim.p){case"ocean":a.camera.position.z=Math.sin(t*(e.anim.s/100))*(e.particle.a/3)+e.particle.a/3,a.camera.position.y=e.a/3,a.camera.lookAt(0,0,-e.particle.a/3);break;case"lost":a.scene.rotation.y+=a.tDiff/1e3*e.anim.s,a.camera.position.z=Math.sin(t*(e.anim.s/40))*(e.particle.a/6)+e.particle.a/6;break;case"round":a.camera.position.set(e.particle.a/4,e.a,0),a.scene.rotation.y-=a.tDiff/1e3*e.anim.s,a.camera.rotation.y=Math.PI/3,a.camera.rotation.x=-1*Math.PI/180,a.camera.rotation.z=1*Math.PI/180;break;case"oceanEdge":a.camera.position.z=Math.sin(t*(e.anim.s/100))*(e.particle.a/3)+e.particle.a/3,a.scene.rotation.z=Math.PI/2,a.camera.position.y=e.a/3,a.camera.lookAt(0,0,-e.particle.a/3);break;case"quarterPipe":a.camera.position.z=Math.sin(t*(e.anim.s/100))*(e.particle.a/3)+e.particle.a/3,a.camera.position.y=e.a/3,a.scene.rotation.x=Math.sin(t*(e.anim.s/100))*Math.PI/4+Math.PI/4;break;case"upAnDown":a.camera.position.z=Math.sin(t*(e.anim.s/50))*(e.particle.a/3)+e.particle.a/3,a.camera.position.y=Math.cos(t*(e.anim.s/50))*(e.particle.a/6),a.camera.lookAt(0,0,-e.particle.a/3),a.scene.rotation.y+=a.tDiff/1e3*e.anim.s;break;case"oceanEdgeSpin":a.camera.position.z=Math.sin(t*(e.anim.s/100))*(e.particle.a/3)+e.particle.a/3,a.camera.position.y=e.a/3,a.camera.lookAt(0,0,-e.particle.a/3),a.scene.rotation.z-=a.tDiff/400*e.anim.s}},pathHexa:(a,t)=>{let e=a.settings;switch(e.anim.pH){case"ocean":a.scene.rotation.x=(e.scene.t+37)*Math.PI/180,a.scene.position.z=2,a.camera.position.x=Math.sin(t*(e.anim.s/100))*(e.particle.a/12),a.camera.position.y=Math.cos(t*(e.anim.s/100))*(e.particle.a/14)+e.particle.a/12;break;case"round":a.scene.rotation.x=(e.scene.t+37)*Math.PI/180,a.camera.position.x=Math.sin(t*(e.anim.s/100))*(e.particle.a/6),a.camera.rotation.z-=a.tDiff/1e3*e.anim.s,a.camera.position.z=Math.min(2*Math.sin(t*(e.anim.s/100))+20,2*Math.sin(t*(e.anim.s/50))+18);break;case"handheld":a.scene.rotation.x=(e.scene.t+37)*Math.PI/180,a.camera.position.x=Math.sin(t*(e.anim.s/100))*(e.particle.a/6),a.scene.rotation.z=Math.sin(t*(e.anim.s/100))*(10*Math.PI)/180,a.camera.position.z=Math.min(2*Math.sin(t*(e.anim.s/50))+4*e.a,2*Math.sin(t*(e.anim.s/50))+18);break;case"oldOcean":a.camera.position.z=Math.sin(t*(e.anim.s/100))*(e.particle.a/3)+e.particle.a/3,a.camera.position.y=e.a-Math.sin(t*(e.anim.s/100))*e.a/2,a.camera.lookAt(0,0,-e.particle.a);break;case"oldLost":a.scene.rotation.y+=a.tDiff/1e3*e.anim.s,a.camera.position.y=1.5*e.a,a.camera.position.z=Math.sin(t*(e.anim.s/40))*(e.particle.a/6)+e.particle.a/6;break;case"oldRound":a.camera.position.set(e.particle.a/4,1.5*e.a,0),a.scene.rotation.y-=a.tDiff/1e3*e.anim.s,a.camera.rotation.y=60*Math.PI/180,a.camera.rotation.x=-1*Math.PI/180,a.camera.rotation.z=1*Math.PI/180}},pendulum(a,t){let e=a.settings;var i=Math.max(e.scene.sx,e.pendulum.x),n=Math.min(e.scene.sx,e.pendulum.x),s=Math.max(e.scene.sy,e.pendulum.y),o=Math.min(e.scene.sy,e.pendulum.y),c=Math.max(e.scene.sz,e.pendulum.z),r=Math.min(e.scene.sz,e.pendulum.z),m=new THREE.Vector3(Math.sin(t*(e.anim.s/100))*(i-n)/2+n+(i-n)/2,Math.sin(t*(e.anim.s/100))*(s-o)/2+o+(s-o)/2,Math.sin(t*(e.anim.s/100))*(c-r)/2+r+(c-r)/2+e.particle.a/2);"rounded"==e.pendulum.r&&a.camera.lookAt(-m.x,-m.y,-m.z),a.camera.position.copy(m);var p=Math.max(e.pendulum.t/180*Math.PI,e.scene.t/180*Math.PI),l=Math.min(e.pendulum.t/180*Math.PI,e.scene.t/180*Math.PI);a.scene.rotation.x=Math.sin(t*(e.anim.s/100))*(p-l)/2+l+(p-l)/2,a.camera.position.z=m.z+10;var h=Math.max(e.pendulum.a/180*Math.PI,e.scene.a/180*Math.PI),M=Math.min(e.pendulum.a/180*Math.PI,e.scene.a/180*Math.PI);a.scene.rotation.z=Math.sin(t*(e.anim.s/100))*(h-M)/2+M+(h-M)/2},loop:a=>{let t=a.settings;a.scene.rotation.x+=t.loop.t/5e3*a.tDiff*100,a.scene.rotation.y+=t.loop.z/5e3*a.tDiff*100,a.scene.rotation.z+=t.loop.a/5e3*a.tDiff*100}}},_tpt.R??={},_tpt.R.pw_Anim=_tpt.extend?_tpt.extend(_tpt.R.pw_Anim,{status:2,version:"1.0"}):{status:2,version:"1.0"},window.dispatchEvent(new CustomEvent("SR7ParticleWaveAnimLoaded")))}();
!function(){"use strict";window.SR7??={},window._tpt??={},SR7.A??={},SR7.F??={},SR7.D??={},void 0===(SR7.A.particlewave?.updateShader??void 0)&&(SR7.A.particlewave={...SR7.A.particlewave,updateShader:(e,n,a)=>{if(!window.beforeCompile){switch(e.vertexShader=e.vertexShader.replace("#include <common>","\n                #include <common>\n                uniform float u_time;\n                uniform float u_amplitude;\n                uniform float u_speed;\n                uniform float u_curve;\n                uniform vec4 u_color;\n                uniform vec3 u_color_lines;\n                uniform sampler2D u_pointTexture;\n    \n                attribute float wavePosX;\n                attribute float wavePosY;\n                attribute float random_factor;\n                float pi = 3.14159265359;\n    \n                varying float v_wavePosX;\n                varying float v_wavePosY;\n                varying float v_wavePosZ;\n            "),e.vertexShader=e.vertexShader.replace("void main() {","\n                // functions\n                void main() {\n                    v_wavePosX = wavePosX;\n                    v_wavePosY = wavePosY;\n    \n                    float increaser = 0.0;\n            "),n.type){case"default":e.vertexShader=e.vertexShader.replace("#include <morphtarget_vertex>","\n                        float f_speed = (u_time / u_curve) * u_speed;\n                        float offset = sin((f_speed + wavePosX) * u_curve) + sin((f_speed + wavePosY) * u_curve);\n    \n                        increaser += offset + u_amplitude;\n                        \n                        #include <morphtarget_vertex>");break;case"plainx":e.vertexShader=e.vertexShader.replace("#include <morphtarget_vertex>","\n                        float f_speed = (u_time / u_curve) * u_speed;\n                        float offset = sin((f_speed + wavePosX) * u_curve);\n    \n                        increaser += offset + u_amplitude;\n    \n                        #include <morphtarget_vertex>");break;case"plainz":e.vertexShader=e.vertexShader.replace("#include <morphtarget_vertex>","\n                        float f_speed = (u_time / u_curve) * u_speed;\n                        float offset = sin((f_speed + wavePosY) * u_curve);\n    \n                        increaser += offset + u_amplitude;\n                        \n                        #include <morphtarget_vertex>");break;case"powerful":e.vertexShader=e.vertexShader.replace("#include <morphtarget_vertex>","\n                        float f_speed = (u_time / u_curve) * u_speed;\n                        //float offset = sin(f_speed) + sin(sin(u_curve) * wavePosX) + sin(sin(u_curve) * wavePosY);\n                        float offset = sin((f_speed + wavePosX) * u_curve) * wavePosX + sin((f_speed + wavePosY) * u_curve) * wavePosY;\n    \n                        increaser += offset + u_amplitude;\n    \n                        #include <morphtarget_vertex>");break;case"funky":e.vertexShader=e.vertexShader.replace("#include <morphtarget_vertex>","\n                        float f_speed = sin((u_time / u_curve) * u_speed) * 12.5;\n                        float offset = sin(f_speed * wavePosX+sin(f_speed * wavePosX+sin(f_speed * wavePosX))) + sin(f_speed * wavePosY+sin(f_speed * wavePosY));\n                        \n                        increaser += offset + u_amplitude;\n                        \n                        #include <morphtarget_vertex>")}switch(e.vertexShader=e.vertexShader.replace("#include <morphtarget_vertex>","\n                transformed.y += offset * u_amplitude;\n                v_wavePosZ = transformed.y;\n\n                #include <morphtarget_vertex>"),n.rv&&(e.vertexShader=e.vertexShader.replace("#include <morphtarget_vertex>","\n                    transformed.y += random_factor;\n    \n                    #include <morphtarget_vertex>")),e.fragmentShader=e.fragmentShader.replace("#include <common>","\n                #include <common>\n                uniform vec4 u_color;\n                uniform vec3 u_color_lines;\n                uniform sampler2D u_pointTexture;\n                varying float v_wavePosX;\n                varying float v_wavePosY;\n                varying float v_wavePosZ;\n                uniform float u_amplitude;\n                uniform float u_intensity;\n                uniform float u_isSVG;\n                varying float v_faceOpacity;\n            "),0!==n.numStops&&(e.fragmentShader=e.fragmentShader.replace("#include <common>","\n                    #include <common>\n                    uniform vec2 u_gradientStart;\n                    uniform vec2 u_gradientEnd;\n                    uniform vec4 u_colors[6];\n                    uniform float u_colorstops[6];\n                    uniform int u_numstops;\n                    uniform float u_windowHeight;\n                ")),e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                float opaX = 1.0, opaZ = 1.0;\n                float intens = u_intensity / 100.0;\n                #include <tonemapping_fragment>\n            "),n.balance.f){case"sides":e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                        opaX = -abs((v_wavePosX+0.5)*2.0)+1.0;\n                        #include <tonemapping_fragment>\n                    ");break;case"back":e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                        opaZ = abs(v_wavePosY / 1.0);\n                        #include <tonemapping_fragment>\n                    ");break;case"front":e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                        opaZ = -abs(v_wavePosY / 1.0) + 1.0;\n                        #include <tonemapping_fragment>\n                    ");break;case"backfront":e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                        opaZ = -abs((v_wavePosY-0.5)*2.0)+1.0;\n                        #include <tonemapping_fragment>\n                    ");break;case"all":e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                        opaZ = -abs((v_wavePosY-0.5)*2.0)+1.0;\n                        opaX = -abs((v_wavePosX+0.5)*2.0)+1.0;\n                        #include <tonemapping_fragment>\n                    ")}"color"==n.particle.c&&(0==n.numStops?e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                        vec4 tempColor = vec4(float(u_color.x) / 255.0, float(u_color.y) / 255.0, float(u_color.z) / 255.0, u_color.a);\n                        float oCopy = gl_FragColor.a * tempColor.a;\n                        gl_FragColor = mix(gl_FragColor, tempColor, u_isSVG);\n                        gl_FragColor.a = oCopy;\n                        #include <tonemapping_fragment>\n                    "):e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>",'\n                        /* float  alpha = atan( -u_gradientEnd.y + u_gradientStart.y, u_gradientEnd.x - u_gradientStart.x );\n                        float  gradientXRot = u_gradientStart.x*cos(alpha) - u_gradientStart.y*sin(alpha);\n                        float  gradientXEndRot   = u_gradientEnd.x*cos(alpha) - u_gradientEnd.y*sin(alpha);\n                        float  span = gradientXEndRot - gradientXRot;\n                        float y = 1200.0 * v_wavePosY;\n                        float x = 1600.0 * v_wavePosX;\n                        float xLocRotated = x*cos( alpha ) - y*sin( alpha );\n    \n                        c.x = mix(u_colors[0].x / 255.0, u_colors[1].x / 255.0, smoothstep( gradientXRot + float(u_colorstops[0])*span, gradientXRot + float(u_colorstops[1])*span, xLocRotated ));\n                        c.y = mix(u_colors[0].y / 255.0, u_colors[1].y / 255.0, smoothstep( gradientXRot + float(u_colorstops[0])*span, gradientXRot + float(u_colorstops[1])*span, xLocRotated ));\n                        c.z = mix(u_colors[0].z / 255.0, u_colors[1].z / 255.0, smoothstep( gradientXRot + float(u_colorstops[0])*span, gradientXRot + float(u_colorstops[1])*span, xLocRotated ));\n                        \n                        for( int i=1; i<c_numstops-1; i++ ){\n                            c.x = mix(c.x, u_colors[i+1].x, smoothstep( gradientXRot + float(u_colorstops[i])*span, gradientXRot + float(u_colorstops[i+1])*span, xLocRotated ));\n                            c.y = mix(c.y, u_colors[i+1].y, smoothstep( gradientXRot + float(u_colorstops[i])*span, gradientXRot + float(u_colorstops[i+1])*span, xLocRotated ));\n                            c.z = mix(c.z, u_colors[i+1].z, smoothstep( gradientXRot + float(u_colorstops[i])*span, gradientXRot + float(u_colorstops[i+1])*span, xLocRotated ));\n                        } */\n    \n                        vec4 c = vec4(0.0, 0.0, 0.0, 0.0);\n                        //float posX = (v_wavePosX + 1.0);\n                        float alpha = 0.0 * 3.14/180.0;\n                        float reach = 1.0;\n                        float posX = ((v_wavePosX + 1.0)*cos( alpha ) +  v_wavePosY*sin( alpha )) / reach;\n    \n                        //if needed translate to "v_wavePosZ"\n                        //If scene is no longer hard coded at 30x30, then the reach value must be calculated differently with that in mind\n    \n                        for(int i=0; i<c_numstops; i++){\n                            if(u_colorstops[i] <= posX && posX <= u_colorstops[i+1]){\n                                c.x = mix(u_colors[i+1].x, u_colors[i].x, smoothstep(u_colorstops[i+1], u_colorstops[i], posX));\n                                c.y = mix(u_colors[i+1].y, u_colors[i].y, smoothstep(u_colorstops[i+1], u_colorstops[i], posX));\n                                c.z = mix(u_colors[i+1].z, u_colors[i].z, smoothstep(u_colorstops[i+1], u_colorstops[i], posX));\n                            }\n                        }\n    \n                        float oCopy = gl_FragColor.a;\n                        gl_FragColor = c;\n                        gl_FragColor.a = oCopy;\n    \n                        #include <tonemapping_fragment>\n                    ')),"image"==n.particle.c&&(e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>",`\n                    vec4 color = texture2D(u_pointTexture, ${!1===a?"vec2(abs(v_wavePosX), v_wavePosY)":"vUv"});\n    \n                    float oCopy = gl_FragColor.a * 1.0;\n                    gl_FragColor = mix(color, gl_FragColor, .5);\n                    gl_FragColor.a = oCopy;\n    \n                    #include <tonemapping_fragment>\n                `)),"keep"==n.particle.c&&(e.fragmentShader=e.fragmentShader.replace("#include <dithering_fragment>","\n                    #include <dithering_fragment>\n                ")),e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                gl_FragColor.a = min(opaX * intens, opaZ * intens) * gl_FragColor.a;\n                #include <tonemapping_fragment>\n            ")}},updateShader2:(e,n)=>{if(e.vertexShader=e.vertexShader.replace("#include <common>","\n                #include <common>\n                uniform float u_time;\n                uniform float u_amplitude;\n                uniform float u_speed;\n                uniform float u_curve;\n                uniform vec4 u_color;\n                uniform vec3 u_color_lines;\n    \n                attribute float wavePosX;\n                attribute float wavePosY;\n                attribute float random_factor;\n                float pi = 3.14159265359;\n    \n                varying float v_wavePosX;\n                varying float v_wavePosY;\n                varying float v_hexaLightDiff;\n            "),e.vertexShader=e.vertexShader.replace("void main() {","\n                // functions\n                void main() {\n                    v_wavePosX = wavePosX;\n                    v_wavePosY = wavePosY;\n            "),"hexa"!==n.lines.con&&"off"!=n.lines.con&&0==n.lines.bF&&(e.vertexShader=e.vertexShader.replace("#include <common>","\n                    #include <common>\n                    varying float v_faceOpacity;\n                    attribute float a_faceColor;\n                ").replace("void main() {","\n                    // functions\n                    void main() {\n                        v_wavePosX = wavePosX;\n                        v_wavePosY = wavePosY;\n                        v_faceOpacity = a_faceColor;\n    \n                ")),"hexa"!==n.lines.con){switch(n.type){case"default":e.vertexShader=e.vertexShader.replace("#include <morphtarget_vertex>","\n                            float f_speed = (u_time / u_curve) * u_speed;\n                            float offset = sin((f_speed + wavePosX) * u_curve) + sin((f_speed + wavePosY) * u_curve);\n            \n                            transformed.y += offset * u_amplitude;\n            \n                            #include <morphtarget_vertex>");break;case"plainx":e.vertexShader=e.vertexShader.replace("#include <morphtarget_vertex>","\n                            float f_speed = (u_time / u_curve) * u_speed;\n                            float offset = sin((f_speed + wavePosX) * u_curve);\n            \n                            transformed.y += offset * u_amplitude;\n                            #include <morphtarget_vertex>");break;case"plainz":e.vertexShader=e.vertexShader.replace("#include <morphtarget_vertex>","\n                            float f_speed = (u_time / u_curve) * u_speed;\n                            float offset = sin((f_speed + wavePosY) * u_curve);\n            \n                            transformed.y += offset * u_amplitude;\n                            #include <morphtarget_vertex>");break;case"powerful":e.vertexShader=e.vertexShader.replace("#include <morphtarget_vertex>","\n                            float f_speed = (u_time / u_curve) * u_speed;\n                            //float offset = sin(f_speed) + sin(sin(u_curve) * wavePosX) + sin(sin(u_curve) * wavePosY);\n                            float offset = sin((f_speed + wavePosX) * u_curve) * wavePosX + sin((f_speed + wavePosY) * u_curve) * wavePosY;\n            \n                            transformed.y += offset * u_amplitude;\n                            #include <morphtarget_vertex>");break;case"funky":e.vertexShader=e.vertexShader.replace("#include <morphtarget_vertex>","\n                            float f_speed = sin((u_time / u_curve) * u_speed) * 12.5;\n                            float offset = sin(f_speed * wavePosX+sin(f_speed * wavePosX+sin(f_speed * wavePosX))) + sin(f_speed * wavePosY+sin(f_speed * wavePosY));\n                            \n                            transformed.y += offset * u_amplitude;\n                            #include <morphtarget_vertex>")}n.rv&&(e.vertexShader=e.vertexShader.replace("#include <morphtarget_vertex>","\n                        transformed.y += random_factor;\n            \n                        #include <morphtarget_vertex>"))}else e.vertexShader=e.vertexShader.replace("#include <morphtarget_vertex>","\n    \n                    float f_speed = (u_time / u_curve) * u_speed;\n                    float offset = sin((f_speed + wavePosX) * u_curve) + sin((f_speed + wavePosY) * u_curve) + u_amplitude / 2.0;\n                    float maxoffset = 2. + u_amplitude / 2.0;\n                    float hexaLightVal = abs(offset/maxoffset/10.);\n    \n                    if(a_hexaCount > 0.0){\n                        transformed.y += offset * u_amplitude / 4.0;\n                        v_hexaLightDiff = 0.8 + hexaLightVal;\n                    }\n                    else{\n                        hexaLightVal = abs(offset/maxoffset/20.);\n                        v_hexaLightDiff = 0.8 + hexaLightVal;\n                        transformed.y += offset * u_amplitude / 8.0;\n                    }\n                    #include <morphtarget_vertex>");switch(e.fragmentShader=e.fragmentShader.replace("#include <common>","\n                #include <common>\n                uniform vec4 u_color;\n                uniform vec3 u_color_lines;\n                uniform sampler2D u_pointTexture;\n                varying float v_wavePosX;\n                varying float v_wavePosY;\n                uniform float u_intensity;\n                varying float v_hexaLightDiff;\n            "),0!==n.numStops&&(e.fragmentShader=e.fragmentShader.replace("#include <common>","\n                    #include <common>\n                    uniform vec2 u_gradientStart;\n                    uniform vec2 u_gradientEnd;\n                    uniform vec4 u_colors[6];\n                    uniform float u_colorstops[6];\n                    uniform int u_numstops;\n                    uniform float u_windowHeight;\n                ")),"hexa"!==n.lines.con&&"off"!=n.lines.con&&0==n.lines.bF&&(e.fragmentShader=e.fragmentShader.replace("#include <common>","\n                    #include <common>\n                    varying float v_faceOpacity;\n                ")),e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                float opaX = 1.0, opaZ = 1.0;\n                #include <tonemapping_fragment>\n            "),n.balance.f){case"sides":e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                        opaX = -abs((v_wavePosX+0.5)*2.0)+1.0;\n                        #include <tonemapping_fragment>\n                    ");break;case"back":e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                        opaZ = abs(v_wavePosY / 1.0);\n                        #include <tonemapping_fragment>\n                    ");break;case"front":e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                        opaZ = -abs(v_wavePosY / 1.0) + 1.0;\n                        #include <tonemapping_fragment>\n                    ");break;case"backfront":e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                        opaZ = -abs((v_wavePosY-0.5)*2.0)+1.0;\n                        #include <tonemapping_fragment>\n                    ");break;case"all":e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                        opaZ = -abs((v_wavePosY-0.5)*2.0)+1.0;\n                        opaX = -abs((v_wavePosX+0.5)*2.0)+1.0;\n                        #include <tonemapping_fragment>\n                    ")}"off"!==n.lines.con?("color"==n.particle.c&&n.numStops>0&&0==n.lines.cC&&(e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>",'\n                                vec4 c = vec4(0.0, 0.0, 0.0, 0.0);\n                                //float posX = (v_wavePosX + 1.0);\n                                float alpha = 0.0 * 3.14/180.0;\n                                float reach = 1.0;\n                                float posX = ((v_wavePosX + 1.0)*cos( alpha ) +  v_wavePosY*sin( alpha )) / reach;\n        \n                                //if needed translate to "v_wavePosZ"\n                                //If scene is no longer hard coded at 30x30, then the reach value must be calculated differently with that in mind\n        \n                                for(int i=0; i<c_numstops; i++){\n                                    if(u_colorstops[i] <= posX && posX <= u_colorstops[i+1]){\n                                        c.x = mix(u_colors[i+1].x, u_colors[i].x, smoothstep(u_colorstops[i+1], u_colorstops[i], posX));\n                                        c.y = mix(u_colors[i+1].y, u_colors[i].y, smoothstep(u_colorstops[i+1], u_colorstops[i], posX));\n                                        c.z = mix(u_colors[i+1].z, u_colors[i].z, smoothstep(u_colorstops[i+1], u_colorstops[i], posX));\n                                    }\n                                }\n        \n                                float oCopy = gl_FragColor.a;\n                                gl_FragColor = c;\n                                gl_FragColor.a = oCopy;\n                                #include <tonemapping_fragment>\n                        ')),"image"==n.particle.c&&(n.lines.cC?e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                            vec4 color = texture2D(u_pointTexture, vUv);\n    \n                            gl_FragColor = vec4(float(u_color.x) / 255.0, float(u_color.y) / 255.0, float(u_color.z) / 255.0, u_color.a);\n    \n                            #include <tonemapping_fragment>\n                        "):e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                            vec4 color = texture2D(u_pointTexture, vUv);\n    \n                            float oCopy = gl_FragColor.a * color.a;\n                            gl_FragColor = color;\n                            gl_FragColor.a = oCopy;\n    \n                            #include <tonemapping_fragment>\n                        ")),n.lines.bF?("boxes"==n.lines.con&&(e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                            float intens = u_intensity / 100.0;\n                            gl_FragColor.a = min(opaX * intens, opaZ * intens) * gl_FragColor.a * v_faceOpacity;\n                            #include <tonemapping_fragment>\n                        ")),"triangles"==n.lines.con&&(e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                            float intens = u_intensity / 100.0;\n                            gl_FragColor.a = min(opaX * intens, opaZ * intens) * gl_FragColor.a * v_faceOpacity;\n                            #include <tonemapping_fragment>\n                        "))):e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>",`\n                        float intens = u_intensity / 100.0;\n                        ${"hexa"===n.lines.con?"gl_FragColor.rgb *= v_hexaLightDiff;":""}\n                        gl_FragColor.a = min(opaX * intens, opaZ * intens) * gl_FragColor.a;\n    \n                        #include <tonemapping_fragment>\n                    `)):!n.numStops&&n.numStops.length<0?e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                    float intens = u_intensity / 100.0;\n                    gl_FragColor.a = min(opaX * intens, opaZ * intens) * gl_FragColor.a * u_color.a;\n    \n                        #include <tonemapping_fragment>\n                    "):e.fragmentShader=e.fragmentShader.replace("#include <tonemapping_fragment>","\n                    float intens = u_intensity / 100.0;\n                    gl_FragColor.a = min(opaX * intens, opaZ * intens) * gl_FragColor.a;\n    \n                        #include <tonemapping_fragment>\n                    ")}},_tpt.R??={},_tpt.R.pw_Shaders=_tpt.extend?_tpt.extend(_tpt.R.pw_Shaders,{status:2,version:"1.0"}):{status:2,version:"1.0"},window.dispatchEvent(new CustomEvent("SR7ParticleWaveShadersLoaded")))}();
!function(){"use strict";window.SR7??={},window._tpt??={},SR7.A??={},SR7.F??={},SR7.D??={},void 0===(SR7.A.particlewave?.tools??void 0)&&(SR7.A.particlewave={...SR7.A.particlewave,tools:{ToQuads:t=>{let e=t.parameters,r=e.tubularSegments||e.widthSegments||e.thetaSegments||e.points?.length-1||1,a=e.radialSegments||e.heightSegments||e.phiSegments||e.segments||1;"TorusGeometry"===t.type&&([r,a]=[a,r]);let o=[],s=(r+1)*(a+1);for(let t=0;t<=a;t++){let e=t*(r+1);for(let t=0;t<r;t++){let a=e+t,n=a+1,i=a+r+1;o.push(a,n),i<s-1&&o.push(a,i)}e+r+1<s-1&&o.push(e+r,e+r+r+1)}t.setIndex(o)},separateFaces:(t,e)=>{const r=t.attributes.position.array,a=t.attributes.uv.array,o=t.attributes.normal.array;let s=0,n=0;const i=(e,r)=>{let a;return t.setAttribute(e,new THREE.BufferAttribute(a=new Float32Array(t.index.count*r),r)),a},l=i("position",3),p=i("uv",2),c=i("normal",3);e.forEach((e=>{const r=t.attributes[e.name];e.oArr=r.array,e.nArr=i(e.name,r.itemSize)}));let d=t.index.array;t.index.count-1>65535&&t.index.count<4294967295&&(d=new Uint32Array(t.index.count));for(let i=0;i<t.index.count;i++){const w=t.index.array[i];d[i]=i,l.set(r.subarray(3*w,3*w+3),s),p.set(a.subarray(2*w,2*w+2),n),c.set(o.subarray(3*w,3*w+3),s),e.forEach((e=>{const r=t.attributes[e.name],a=w*r.itemSize;e.nArr.set(e.oArr.subarray(a,a+r.itemSize),i*r.itemSize)})),s+=3,n+=2}t.index.array=d,t.attributes.uv.needsUpdate=!0,t.attributes.position.needsUpdate=!0,t.attributes.normal.needsUpdate=!0,e.forEach((e=>t.attributes[e.name].needsUpdate=!0))},analyseGradient:(t,e,r)=>{let a=t.wpC_ori.angle;if("solid"!=(t.wpC?.type??"solid")&&t.wpC.colors?.length){t.numStops=t.wpC.colors.length,t.colorsArray=[],t.colorStopsArray=[];for(let e=0;e<6;e++){const r=e,a=new THREE.Vector4;e<t.numStops?(a.fromArray(_tpt.parseColor(t.wpC.colors[r].rgba)),t.colorsArray.push(a),t.colorStopsArray.push(t.wpC.colors[r].p/100)):(t.colorsArray.push(a),t.colorStopsArray.push(0))}const{tx:o,ty:s,bx:n,by:i}=_tpt.gradient.calcPoints(e,r,a);t.gradientStart.set(o,s),t.gradientEnd.set(n,i)}else t.numStops=0,t.wpC=(new THREE.Vector4).fromArray(t.color_par)},updateGradientTexture:t=>{let e=t.addOns.particlewave,r=e.settings;if("solid"==(r.wpC_ori?.type??"solid")||void 0===e.w||isNaN(e.w)||0===e.w||void 0===e.h||isNaN(e.h)||0===e.h)return;r.bg.canvas.width=e.w,r.bg.canvas.height=e.h;let a="radial"===r.wpC_ori?.type?r.bg.ctx.createRadialGradient(e.w/2,e.h/2,0,e.w/2,e.h/2,Math.max(e.w/2,e.h/2)):_tpt.gradient.getLinear(r.bg.ctx,e.w,e.h,r.wpC_ori?.angle||180);for(var o=0;o<r.wpC_ori?.colors.length;o++)a.addColorStop(r.wpC_ori?.colors[o].p/100,r.wpC_ori?.colors[o].rgba);r.bg.ctx.fillStyle=a,r.bg.ctx.fillRect(0,0,e.w,e.h),r.bg.ctx.scale(-1,1),r.bg.ctx.drawImage(r.bg.ctx.canvas,-e.w,0,e.w,e.h),r.bg.ctx.setTransform(1,0,0,1,0,0),r.bg.texture.needsUpdate=!0},particleOnCanvas:(t,e,r,a)=>{const o=Math.max(t,e)+4;r.width=t,r.height=e,a.canvas.width=a.canvas.height=o,["webkitImageSmoothingEnabled","msImageSmoothingEnabled","imageSmoothingEnabled"].forEach((t=>a[t]=!1)),a.drawImage(r,(o-t)/2+2,(o-e)/2+2,t-4,e-4)}}},_tpt.R??={},_tpt.R.pw_Tools=_tpt.extend?_tpt.extend(_tpt.R.pw_Tools,{status:2,version:"1.0"}):{status:2,version:"1.0"},window.dispatchEvent(new CustomEvent("SR7ParticleWaveToolsLoaded")))}();
!function(){"use strict";if(window.SR7??={},window._tpt??={},SR7.A??={},SR7.F??={},SR7.D??={},void 0!==(SR7.A.particlewave?.waves??void 0))return;SR7.A.particlewave={...SR7.A.particlewave,waves:{build:e=>{let i=SR7.A.particlewave,o=e.addOns.particlewave,u=o.settings;t(e),a(o,u);let m=l(u);if("hexa"!=u.lines.con){if(1==u.particle.on){const e=new THREE.BufferGeometry;e.setAttribute("position",new THREE.Float32BufferAttribute(m.points,3)),e.setAttribute("wavePosX",new THREE.Float32BufferAttribute(m.wavePosX,1)),e.setAttribute("wavePosY",new THREE.Float32BufferAttribute(m.wavePosY,1)),e.setAttribute("random_factor",new THREE.Float32BufferAttribute(m.random_factor,1));let t=new THREE.Points(e,o.material,m.count);o.group.add(t)}o.group.rotation.y=Math.PI;let e=new THREE.AmbientLight;o.group.add(e),i.adjustScene(o)}else r(o.scene,u),i.setSceneForHexa(o);"off"===u.lines.con||!u.lines.bF&&"hexa"!==u.lines.con||n(o,u,m),"off"===u.lines.con||"hexa"===u.lines.con||u.lines.bF||s(o,u,m),o.scene.add(o.group),o.renderer=new THREE.WebGLRenderer({antialias:!0,canvas:o.canvas.canvas,alpha:!0}),o.renderer.setPixelRatio(Math.min(u.scene.dpr,window.devicePixelRatio)),o.renderer.setSize(o.canvas.canvas.width,o.canvas.canvas.height),o.bindedRender=t=>{i.waves.render(e,t)},i.waves.initPP(e),c(e)},render:(e,t)=>{let a=SR7.A.particlewave,{id:r}=SR7.F.getLayer(e.el.id),n=e.addOns.particlewave,i=n.settings;if(n.destroyed||n.paused||(n.frame=cancelAnimationFrame(n.frame),n.frame=requestAnimationFrame(n.bindedRender)),void 0!==t&&void 0!==n.time){n.tDiff=(t-n.time)/1600,n.time=t,void 0!==n.lastDim&&n.lastDim.width===e.cw&&n.lastDim.height===e.ch||a.fitCameraToObject(e);if(i.clock.getElapsedTime()>i.clockCounter*(1/60)){if("timelinebased"===i.interaction.type){let t=e.tl?.[e.animState?.scene??void 0]?.TL?.time()||void 0;t&&(n.material.userData.u_time.value+=.1*(t-n.material.userData.u_time.value))}else if("scrollbased"===i.interaction.type&&SR7.M[r].settings.sbt?.use){let t=SR7.M[e.mid],a=Math.min(1,Math.max(0,(0-t.dims.moduleRect?.top??0)/((t.dims.moduleRect?.height??t.dims.module.h)-t.dims.module.h)));n.group.rotation.x+=.1*(i.interaction.t*a-n.group.rotation.x),n.group.rotation.z+=.1*(i.interaction.r*a-n.group.rotation.z),n.group.position.y+=.1*(i.interaction.sh*a-n.group.position.y),n.material.userData.u_time.value+=n.tDiff}else n.material.userData.u_time.value+=n.tDiff;i.clockCounter+=n.tDiff}"off"!=i.anim.mov&&a.anim.selector(n),"mousefollow"===i.interaction.type&&a.listeners.mouse.applyfollow(n),("glitch"!=i.design.fx||"hexa"!=i.lines.con)&&n.pp&&n.pp.composer?("bokeh"===i.design.fx&&(n.pp.effectPass.uniforms.maxblur.value=i.design.bb?_tpt.gsap.utils.mapRange(0,1,i.design.minb,i.design.maxb,Math.abs(Math.sin(Math.PI*(n.material.userData.u_time.value+.5)*.3))):i.design.maxb),"glitch"==i.design.fx&&(n.pp.effectPass.uniforms.width.value=e.cw,n.pp.effectPass.uniforms.height.value=e.ch,n.pp.effectPass.uniforms.progress.value=n.material.userData.u_time.value),n.pp.composer.render()):n.renderer.render(n.scene,n.camera)}else n.time=t},initPP:e=>{let t=e.addOns.particlewave,a=t.settings;if(t&&"off"!==a.design.fx&&!t.ppEnabled&&void 0!==e.cw&&void 0!==e.ch&&0!==e.cw&&0!==e.ch)switch(t.ppEnabled=!0,a.design.fx){case"bokeh":t.pp=SR7.WEBGL.postProcessing("BokehPass",t.renderer,t.scene,t.camera,{focus:a.design.f/1,aperture:1e-5*a.design.a,maxblur:a.design.maxb,transparent:!0,width:e.cw,height:e.ch});break;case"glitch":t.pp=SR7.WEBGL.postProcessing("GlitchNoisePass",t.renderer,t.scene,t.camera,{progress:2,transparent:!0,duration:1,width:e.cw,height:e.ch})}},update:e=>{let t=SR7.A.particlewave,a=e.addOns.particlewave,r=a.settings;a.material.userData.u_amplitude.value=r.a,a.material.userData.u_speed.value=r.s,a.material.userData.u_curve.value=r.curve,a.material.userData.u_scale.value=r.particle.gs,"hexa"==a.settings.lines?t.setSceneForHexa(a):t.adjustScene(a)},resize:(e,t,a)=>{let r=e.addOns.particlewave;r.w=t,r.h=a,r.camera&&(r.camera.aspect=r.w/r.h,r.camera.updateProjectionMatrix(),r.renderer.setSize(r.w,r.h))},destroy:t=>{let a=t.addOns.particlewave;a&&(a.destroyed=!0,e(a),a.frame&&(cancelAnimationFrame(a.frame),a.frame=null),a.renderer=null,a.scene=null,a.camera=null)}}};const e=e=>{e.material&&(e.material.map&&e.material.map.dispose(),e.material.dispose(),e.material=null),e.group&&(e.group.traverse((e=>{(e.isMesh||e.isPoints)&&(e.geometry&&e.geometry.dispose(),e.material&&(e.material.map&&e.material.map.dispose(),e.material.dispose()))})),e.scene.remove(e.group),e.group=null),e.texture&&(e.texture.dispose(),e.texture=null),e.renderer&&(e.renderer.dispose(),e.renderer.domElement.remove(),e.renderer.domElement=null)};let t=e=>{let t=e.addOns.particlewave,a=t.settings;t.camera=new THREE.PerspectiveCamera(70,e.cw/e.ch,1,1e3),t.scene=new THREE.Scene,t.group=new THREE.Group,t.camera.position.z=20,SR7.A.particlewave.tools.analyseGradient(a,t.canvas.canvas.width,t.canvas.canvas.height),t.texture=new THREE.CanvasTexture(a.canvastemp),t.texture.needsUpdate=!0,a.clockCounter??=0},a=(e,t)=>{e.material=new THREE.PointsMaterial({map:e.texture,side:THREE.DoubleSide,transparent:!0,size:t.particle.s}),"off"!==t.blend&&(e.material.depthTest=!1);const a={additive:THREE.AdditiveBlending,normal:THREE.NormalBlending,custom:THREE.CustomBlending};e.material.blending=a[t.blend],Object.assign(e.material.userData,{u_time:{value:0},u_rp:{value:!1},u_amplitude:{value:t.a},u_speed:{value:t.s},u_curve:{value:t.c},u_scale:{type:"f",value:t.particle.gs},u_color:{value:t.color_par},u_color_lines:{value:t.color},u_pointTexture:{value:t.bg?.texture??void 0},u_intensity:{value:t.balance.oI},u_gradientStart:{value:t.gradientStart},u_gradientEnd:{value:t.gradientEnd},u_colors:{value:t.colorsArray},u_colorstops:{value:t.colorStopsArray},u_numstops:{value:t.numStops},u_windowHeight:{value:800},u_isSVG:{value:t.isSVG?1:"keep"==t.particle.c?0:1}}),e.material.onBeforeCompile=function(a){i(a.uniforms,e.material.userData),a.uniforms.u_scale=e.material.userData.u_scale,a.vertexShader=a.vertexShader.replace("#include <common>","\n                    #include <common>\n                    attribute float a_faceColor;\n                    varying float v_faceOpacity;\n                    uniform float u_scale;\n                ").replace("void main() {","\n                    float map(float a, float b, float c, float d, float v, float cmin, float cmax) {\n                        return clamp((v - a) * (d - c) / (b - a) + c, cmin, cmax);\n                    }\n                    void main() {\n                        v_faceOpacity = a_faceColor;\n                ").replace("#include <project_vertex>","\n                    vec4 mvPosition = vec4( transformed, 1.0 );\n                    #ifdef USE_INSTANCING\n                        mvPosition = instanceMatrix * mvPosition;\n                    #endif\n                    mvPosition = modelViewMatrix * mvPosition;\n                    gl_Position = projectionMatrix * mvPosition;\n                ").replace("gl_PointSize = size;","\n                    gl_PointSize = size * map( 0., 1., 1. - u_scale, 1. + u_scale, offset, 1. - u_scale, 1. + u_scale);\n                "),a.fragmentShader=a.fragmentShader.replace("#include <common>",`\n                    #include <common>\n                    const int c_numstops = ${t.numStops};\n                `),SR7.A.particlewave.updateShader(a,t,!1)}};const r=(e,t)=>{const a=t.wpC.length/2,r=(e,t,a,r)=>{const n=new THREE.PointLight(e,.2,100);return n.position.set(t,a,r),n},n=(t,a)=>{for(let n=0;n<6;n++){const i=12*n-24;e.add(r(t,i,-10,0+-3*a*12),r(t,i,10,0+-3*a*12))}};if(isNaN(a)){const e=_tpt.getHexColor(t.color_par);for(let t=0;t<2;t++)n(e,t)}else{const e=Array(6).fill(!1),a=t.colorStopsArray.map((e=>Math.round(5*e)));a.forEach(((t,a)=>{e.includes(t)&&(e[t]=a)})),e.forEach(((t,r)=>{if(!1===t){const t=a.map((e=>e-r)),n=t.map(Math.abs),i=Math.min(...n),o=n.findIndex((e=>e===i));e[r]=e[r+t[o]]}}));for(let a=0;a<2;a++)n(new THREE.Color(t.wpC[2*e[a]]),a)}};let n=(e,t,a)=>{let r,n,{points:s,wavePosX:l,wavePosY:c,random_factor:u}=a;for(var m=new THREE.PlaneGeometry(1,1,t.particle.a-1,t.particle.a-1),d=m.attributes.position.array,p=m.attributes.normal.array,f=0;f<m.attributes.position.count;f++){var v=3*f;d.set(s.subarray(v,v+3),v),p.set([0,1,0],v)}if("hexa"!==t.lines.con)r=_tpt.getHexColor(t.particle.on&&t.lines.cC?t.color:t.color_par),n=new THREE.MeshStandardMaterial({color:r,side:THREE.DoubleSide,transparent:!0,depthTest:!1});else{const S={color:16777215,side:THREE.DoubleSide,transparent:!0},x="matte"===t.lines.f?THREE.MeshLambertMaterial:THREE.MeshPhongMaterial;x===THREE.MeshPhongMaterial&&(S.shininess=60),n=new x(S)}m.setAttribute("wavePosX",new THREE.BufferAttribute(l,1)),m.setAttribute("wavePosY",new THREE.BufferAttribute(c,1)),m.setAttribute("random_factor",new THREE.BufferAttribute(u,1)),SR7.A.particlewave.tools.separateFaces(m,[{name:"wavePosX",size:1},{name:"wavePosY",size:1},{name:"random_factor",size:1}]);var _=new Float32Array(m.index.count);if(m.setAttribute("a_faceColor",new THREE.BufferAttribute(_,1)),"triangles"===t.lines.con)for(f=0;f<m.attributes.position.count;f++)m.attributes.a_faceColor.array[f]=f%6>2?0:1;if("boxes"===t.lines.con)for(f=0;f<m.attributes.position.count;f+=12){let y=.7*Math.sin(Math.PI*f/m.attributes.position.count)+.3;for(var w=0;w<12;w++)m.attributes.a_faceColor.array[f+w]=y}var g=new Float32Array(m.index.count);if(m.setAttribute("a_hexaCount",new THREE.BufferAttribute(g,1)),"hexa"===t.lines.con){var h=m.attributes.a_faceColor.array,E=m.attributes.a_hexaCount.array,b=t.particle.a*(t.particle.a/2);function T(e,t,a){for(var r=0;r<a.length;r++)e[t+r]=a[r]}for(f=1;f<b;f+=1.5){let A=12*f;T(h,A+3,[1,1,1,1,1,1,1,1,1]),T(h,A+174,[1,1,1,1,1,1,1,1,1]),E[A]=E[A+4]=E[A+7]=E[A+9]=E[A+177+2]=E[A+174+2]=f}}e.material.userData.u_color={value:t.color_par},n.onBeforeCompile=function(a){i(a.uniforms,e.material.userData),a.uniforms.u_pointTexture=e.material.userData.u_pointTexture,a.vertexShader=a.vertexShader.replace("#include <common>","\n                #include <common>\n                attribute float a_faceColor;\n                attribute float a_hexaCount;\n                varying float v_faceOpacity;\n                uniform float u_scale;\n            ").replace("void main() {","\n                // functions\n                void main() {\n                    v_faceOpacity = a_faceColor;\n            "),SR7.A.particlewave.updateShader2(a,t),a.fragmentShader=a.fragmentShader.replace("#include <common>",`\n                #include <common>\n                const int c_numstops = ${t.numStops};\n                varying float v_faceOpacity;\n            `),o(a)};var R=new THREE.Mesh(m,n);e.group.add(R)},i=(e,t)=>{e.u_time=t.u_time,e.u_amplitude=t.u_amplitude,e.u_speed=t.u_speed,e.u_curve=t.u_curve,e.u_color=t.u_color,e.u_color_lines=t.u_color_lines,e.u_intensity=t.u_intensity,e.u_pointTexture=t.u_pointTexture,e.u_gradientStart=t.u_gradientStart,e.u_gradientEnd=t.u_gradientEnd,e.u_colors=t.u_colors,e.u_colorstops=t.u_colorstops,e.u_numstops=t.u_numstops,e.u_windowHeight=t.u_windowHeight,e.u_isSVG=t.u_isSVG},o=e=>{e.vertexShader=e.vertexShader.replace("#include <common>","\n\t\t\t\t#include <common>\n\t\t\t\t#define USE_UV true"),e.fragmentShader=e.fragmentShader.replace("#include <common>","\n\t\t\t\t#include <common>\n\t\t\t\t#define USE_UV true")},s=(e,t,a)=>{let{points:r,wavePosX:n,wavePosY:s,random_factor:l}=a;var c=new THREE.PlaneGeometry(1,1,t.particle.a-1,t.particle.a-1);c.attributes.position.array.set(r);const u=[0,1,0],m=new Float32Array(3*c.attributes.normal.count);for(let e=0;e<m.length;e+=3)m.set(u,e);c.attributes.normal.array.set(m);var d,p,f=c;("boxes"===t.lines.con&&SR7.A.particlewave.tools.ToQuads(f),"triangles"===t.lines.con)?(p=t.particle.on&&t.lines.cC?_tpt.getHexColor(t.color):_tpt.getHexColor(t.color_par),d=new THREE.Mesh(f,new THREE.MeshBasicMaterial({color:p,wireframe:!0,transparent:!0,opacity:t.lines.o}))):"boxes"===t.lines.con&&(t.lines.cC?((d=new THREE.LineSegments(f)).material.color=new THREE.Color(_tpt.getHexColor(t.color)),d.material.transparent=!0,d.material.opacity=t.lines.o):0==t.numStops?((d=new THREE.LineSegments(f)).material.color=new THREE.Color(_tpt.getHexColor(t.color_par)),d.material.transparent=!0,d.material.opacity=t.lines.o):((d=new THREE.LineSegments(f)).material.color=new THREE.Color(_tpt.getHexColor(t.color)),d.material.transparent=!0,d.material.opacity=t.lines.o));d.geometry.setAttribute("wavePosX",new THREE.BufferAttribute(n,1)),d.geometry.setAttribute("wavePosY",new THREE.BufferAttribute(s,1)),d.geometry.setAttribute("random_factor",new THREE.BufferAttribute(l,1)),d.material.userData.u_color={value:t.color},d.material.onBeforeCompile=function(a){i(a.uniforms,e.material.userData),a.uniforms.u_pointTexture=e.material.userData.u_pointTexture,a.fragmentShader=a.fragmentShader.replace("#include <common>",`\n                #include <common>\n                const int c_numstops = ${t.numStops};\n            `),SR7.A.particlewave.updateShader2(a,t),o(a)},e.group.add(d)},l=e=>{for(var t,a,r=e.particle.a*e.particle.a,n=new Float32Array(r),i=new Float32Array(r),o=new Float32Array(r),s=0,l=0,c=-(1*e.particle.a-1)/2,u=(1*e.particle.a-1)/2,m=new Float32Array(3*r),d=0;d<1*e.particle.a;d+=1){l=0,t=d/e.particle.a;for(var p=0;p>1*-e.particle.a;p-=1)m[3*s]=(c-p)*e.particle.g,m[3*s+1]=0,m[3*s+2]=(u-d)*e.particle.g+("hexa"==e.lines.con?l%2==0?-e.lines.hS:e.lines.hS:0),a=p/e.particle.a,n[s]=Math.sin(a),i[s]=Math.sin(t),o[s]=(Math.random()*e.rv-e.rv/2)/10,s++,l++}return{points:m,wavePosX:n,wavePosY:i,random_factor:o,count:r}},c=e=>{let t=SR7.A.particlewave,a=e.addOns.particlewave;"mousefollow"!=!a.settings.interaction.type&&(_tpt.is_mobile?(a.lerp=.01,a.px=0,a.py=0,a.tx=0,a.ty=0,a.bindedmousefollow=e=>{t.listeners.mouse.follow(a)},window.addEventListener("deviceorientation",(function(e){a.pEvent=e,void 0===a.pFrame&&(a.pFrame=requestAnimationFrame(a.bindedmousefollow))}))):(a.lerp=.001,a.mouseX=.5,a.mouseY=.5,a.targetX=.5,a.targetY=.5,a.settings.interaction.mb||(a.canvas.canvas.addEventListener("mouseenter",(function(a){t.listeners.mouse.enter(a,e)})),a.canvas.canvas.addEventListener("mouseleave",(function(a){t.listeners.mouse.leave(a,e)})),a.canvas.canvas.addEventListener("mousemove",(function(a){t.listeners.mouse.move(a,e)})))))};_tpt.R??={},_tpt.R.pw_Waves=_tpt.extend?_tpt.extend(_tpt.R.pw_Waves,{status:2,version:"1.0"}):{status:2,version:"1.0"},window.dispatchEvent(new CustomEvent("SR7ParticleWaveWavesLoaded"))}();