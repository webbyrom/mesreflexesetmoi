!function(){"use strict";if(window.SR7??={},window._tpt??={},SR7.A??={},SR7.F??={},SR7.D??={},void 0!==SR7.A.fluiddynamics?.init)return;SR7.A.fluiddynamics={...SR7.A.fluiddynamics,init:e=>{void 0===SR7.A.fluiddynamicscss&&(_tpt.injectCssJs(SR7.A.fluiddynamics.style,void 0,void 0,"fluiddynamics_global_styles"),SR7.A.fluiddynamicscss=!0),SR7.M[e].c.moduleListeners??={},SR7.M[e].c.moduleListeners.fluiddynamics??={},_tpt.scrollObserver.observe(SR7.M[e].c.module),SR7.F.module.listeners.init(e),SR7.A.fluiddynamics.listeners.init(e);const i=["THREE","WEBGL"];return null==SR7.A.fluiddynamics.fluid&&i.push("fd_Fluid"),null==SR7.A.fluiddynamics.shaders&&i.push("fd_Shaders"),null==SR7.A.fluiddynamics.tools&&i.push("fd_Tools"),i},getLayerBasics:(e={},i)=>({densityDissipation:e.densityDissipation??69,velocityDissipation:e.velocityDissipation??96,pressureDissipation:e.pressureDissipation??75,followMouse:e.followMouse??"mGenerator",followAMGen:e.followAMGen??"off",automateSel:e.automateSel??"off",curlVal:e.curlVal??15,allColorCount:e.allColorCount??2,fd_color1:e.fd_color1??"#ff0000",fd_color2:e.fd_color2??"#0000ff",fd_color3:e.fd_color3??"#2dfd67",maxOpacityValue:e.maxOpacityValue??80,mousePower:e.mousePower??20,splatRadius:e.splatRadius??20,colorFade:e.colorFade??!1,directionChooser:e.directionChooser??"lr",simuDelay:e.simuDelay??0,simuLength:e.simuLength??36,simuWait:e.simuWait??40,simuPower:e.simuPower??50,simuRadius:e.simuRadius??50,colDirectionChooser:e.colDirectionChooser??"lr",colorChangeType:e.colorChangeType??"timed",colorChangeLenth:e.colorChangeLenth??1.5,colorFull:e.colorFull??!1,vecLength:e.vecLength??50,glow:e.glow??!1,qualityFluid:e.qualityFluid??100,dprFluid:e.dprFluid??"auto",dprOnMobile:e.dprOnMobile??!1,qualityFluidMobile:e.qualityFluidMobile??100,dprFluidMobile:e.dprFluidMobile??1}),prepareLayer:async(e,t,s)=>{if("fluiddynamics"===t.subtype){var{c:o}=SR7.F.getLayer(s);return new Promise((e=>{o.addOns??={},o.addOns.fluiddynamics??={},o.addOns.fluiddynamics=SR7.A.fluiddynamics.getWebGLCanvas(),i(SR7.A.fluiddynamics.getLayerBasics(t.addOns.fluiddynamics)).then((i=>{o.addOns.fluiddynamics.settings=i,o.addOns.fluiddynamics.prepared=!0,o.el.appendChild(o.addOns.fluiddynamics.canvas),e()})).catch((i=>{console.log(i),e()}))}))}},toggle:(e,i)=>{let t=SR7.A.fluiddynamics;const s=SR7.M[e];if(t.onFire)for(let i in t.onFire[e])_tpt.hop(t.onFire[e],i)&&(s.states.inViewPort?t.play(e,s.c.layers[i]):t.pause(e,s.c.layers[i],!1))},play:(e,i)=>{let t=SR7.A.fluiddynamics;i.addOns.fluiddynamics.paused=!1,t.onFire[e][i.el.id]=!0,t.update(i),i.addOns.fluiddynamics.everPlayed||requestAnimationFrame((()=>{i.addOns.fluiddynamics.everPlayed=!0}))},pause:(e,i,t)=>{let s=SR7.A.fluiddynamics;i.addOns.fluiddynamics.paused=!0,i.addOns.fluiddynamics.frame=cancelAnimationFrame(i.addOns.fluiddynamics.frame),t&&s?.onFire?.[e]?.[i.el.id]&&delete s.onFire[e][i.el.id]},listeners:{init:e=>{if(SR7.A.fluiddynamics.listenersAdded?.[e])return;let i=SR7.A.fluiddynamics;i.onFire??={},i.onFire[e]??={},document.addEventListener("sr.layer.action",(function(e){""+(e.layersettings?.addOns?.fluiddynamics??!1)!="false"&&("enterstage"==e.eventtype?(e.c?.addOns?.fluiddynamics?.built||SR7.A.fluiddynamics.build(e.c),SR7.A.fluiddynamics.play(e.id,e.c)):"leavestage"==e.eventtype&&i.pause(e.id,e.c,!0))})),i.listenersAdded??={},i.listenersAdded[e]=!0},mouse:{enter:(e,i)=>{let t=i.addOns.fluiddynamics;t.pointers[t.pointersNum].moved=!0,t.pointers[t.pointersNum].prevTexcoordX=t.pointers[t.pointersNum].texcoordX,t.pointers[t.pointersNum].prevTexcoordY=t.pointers[t.pointersNum].texcoordY,t.pointers[t.pointersNum].texcoordX=e.offsetX/t.canvasRect.width,t.pointers[t.pointersNum].texcoordY=1-e.offsetY/t.canvasRect.height,t.pointers[t.pointersNum].deltaX=0,t.pointers[t.pointersNum].deltaY=0},move:(e,i)=>{let t=i.addOns.fluiddynamics,s=(new Date).getTime();s-t.settings.lastfluidMouseMoveUpdateTime>30&&(t.pointers[t.pointersNum].moved=!0,t.pointers[t.pointersNum].prevTexcoordX=t.pointers[t.pointersNum].texcoordX,t.pointers[t.pointersNum].prevTexcoordY=t.pointers[t.pointersNum].texcoordY,t.pointers[t.pointersNum].texcoordX=e.offsetX/t.canvasRect.width,t.pointers[t.pointersNum].texcoordY=1-e.offsetY/t.canvasRect.height,t.pointers[t.pointersNum].deltaX=(t.pointers[t.pointersNum].texcoordX-t.pointers[t.pointersNum].prevTexcoordX)*t.settings.mousePower,t.pointers[t.pointersNum].deltaY=(t.pointers[t.pointersNum].texcoordY-t.pointers[t.pointersNum].prevTexcoordY)*t.settings.mousePower,t.pointers[t.pointersNum].scrolled&&(t.pointers[t.pointersNum].deltaX=0,t.pointers[t.pointersNum].deltaY=0,t.pointers[t.pointersNum].scrolled=!1),t.settings.lastfluidMouseMoveUpdateTime=s)},touchmove:(e,i)=>{let t=i.addOns.fluiddynamics,s=(new Date).getTime();if(s-t.settings.lastfluidMouseMoveUpdateTime>30){let i=e.touches[0];t.pointers[t.pointersNum].moved=!0,t.pointers[t.pointersNum].prevTexcoordX=t.pointers[t.pointersNum].texcoordX,t.pointers[t.pointersNum].prevTexcoordY=t.pointers[t.pointersNum].texcoordY,t.pointers[t.pointersNum].texcoordX=i.clientX/t.canvasRect.width,t.pointers[t.pointersNum].texcoordY=1-i.clientY/t.canvasRect.height,t.pointers[t.pointersNum].deltaX=(t.pointers[t.pointersNum].texcoordX-t.pointers[t.pointersNum].prevTexcoordX)*t.settings.mousePower,t.pointers[t.pointersNum].deltaY=(t.pointers[t.pointersNum].texcoordY-t.pointers[t.pointersNum].prevTexcoordY)*t.settings.mousePower,t.settings.lastfluidMouseMoveUpdateTime=s}},scroll:(e,i)=>{let t=i.addOns.fluiddynamics;t.pointers[t.pointersNum].scrolled=!0}}},fitCameraToObject:e=>{let i=e.addOns?.fluiddynamics??!1;if(i){let t=Math.round(e.cw??0),s=Math.round(e.ch??0);i.lastDim={width:t,height:s},SR7.A.fluiddynamics.resize(e,t,s),i.paused=!1,cancelAnimationFrame(i.frame),i.frame=requestAnimationFrame(i.bindedRender)}},getWebGLCanvas:function(){let e=document.createElement("canvas");return e.style.width="100%",e.style.height="100%",e.style.position="absolute",e.style.top="0px",e.style.left="0px",e.style.zIndex=2,e.width=1600,e.height=1200,{canvas:e}}};let e=e=>parseFloat(e),i=async i=>(i.curlVal=e(i.curlVal),i.maxOpacityValue=e(i.maxOpacityValue)/100,i.mousePower=e(i.mousePower)/30,i.simuDelay=e(i.simuDelay)+1,i.simuLength=e(i.simuLength)+1,i.simuWait=e(i.simuWait)+1,i.simuPower=e(i.simuPower)/100,i.simuRadius=e(i.simuRadius),i.densityDissipation=.89+e(i.densityDissipation)/1e3,i.velocityDissipation=.89+e(i.velocityDissipation)/1e3,i.pressureDissipation=e(i.pressureDissipation)/100,i.PRESSURE_ITERATIONS=10,i.splatRadiusCache=i.splatRadius,i.splatRadius="mist"==i.automateSel?e(i.splatRadius)/100:e(i.splatRadius)/1250,i.colorChangeLenth=e(i.colorChangeLenth),i.vecLength=e(i.vecLength),i.qualityFluid=e(i.qualityFluid),i.qualityFluidMobile=e(i.qualityFluidMobile),i.allColorCount=e(i.allColorCount)-1,i.fd_color1=_tpt.gradient.convert(i.fd_color1??"#FFFFFF",!0),i.fd_color2=_tpt.gradient.convert(i.fd_color2??"#FFFFFF",!0),i.fd_color3=_tpt.gradient.convert(i.fd_color3??"#FFFFFF",!0),i.fd_color1=SR7.A.fluiddynamics.tools.getRGBA(i.fd_color1.string),i.fd_color2=SR7.A.fluiddynamics.tools.getRGBA(i.fd_color2.string),i.fd_color3=SR7.A.fluiddynamics.tools.getRGBA(i.fd_color3.string),SR7.A.fluiddynamics.tools.resetMaxOpacity(i.fd_color1,i.maxOpacityValue),SR7.A.fluiddynamics.tools.resetMaxOpacity(i.fd_color2,i.maxOpacityValue),SR7.A.fluiddynamics.tools.resetMaxOpacity(i.fd_color3,i.maxOpacityValue),i.vec2=new THREE.Vector2,i.startPos2=new THREE.Vector2,i.startPosNegate=new THREE.Vector2,i.COUNTER=0,i.COUNTER_2=0,i.dt=.016,i);_tpt.R??={},_tpt.R.fluiddynamics=_tpt.extend?_tpt.extend(_tpt.R.fluiddynamics,{status:2,version:"1.0"}):{status:2,version:"1.0"},window.dispatchEvent(new CustomEvent("SR7**AddonName**"))}();
!function(){"use strict";if(window.SR7??={},window._tpt??={},SR7.A??={},SR7.F??={},SR7.D??={},void 0!==(SR7.A.fluiddynamics?.fluid??void 0))return;SR7.A.fluiddynamics={...SR7.A.fluiddynamics,fluiddynamics:!0,build:t=>{let r=t.addOns.fluiddynamics,i=r.settings;r.built=!0,r.pointers=[];const s=()=>r.pointers.push(new SR7.A.fluiddynamics.pointerPrototype);if(s(),"mGeneratorSimu"!==i.followMouse&&"mGeneratorSimu"!==i.followAMGen||s(),"collision"===i.automateSel&&s(),"mist"===i.automateSel){for(let e=0;e<4;e++)s();i.PRESSURE_ITERATIONS=5}else i.PRESSURE_ITERATIONS=10;r.utime=0,r.startTime=Date.now(),Object.assign(r,SR7.A.fluiddynamics.getWebGLContext(r.canvas)),SR7.A.fluiddynamics.createShaders(r),r.updateColorFunction=i.colorFull?e=>{e.colorUpdateTimer+=e.dt*i.colorChangeLenth,e.colorUpdateTimer>=1&&(e.colorUpdateTimer=SR7.A.fluiddynamics.wrap(e.colorUpdateTimer,0,1),e.pointers.forEach((e=>{e.color=SR7.A.fluiddynamics.HSVtoRGB(Math.random()),e.color[3]=i.maxOpacityValue})))}:e=>{},r.dye,r.velocity,r.divergence,r.curl,r.pressure,r.copyProgram=new SR7.A.fluiddynamics.Program(r.baseVertexShader,r.copyShader,r.gl),r.clearProgram=new SR7.A.fluiddynamics.Program(r.baseVertexShader,r.clearShader,r.gl),r.splatProgram=new SR7.A.fluiddynamics.Program(r.baseVertexShader,r.splatShader,r.gl),r.splatProgram2=new SR7.A.fluiddynamics.Program(r.baseVertexShader,r.splatShader2,r.gl),r.advectionProgram=new SR7.A.fluiddynamics.Program(i.isFirefox?r.advectionVertexShader:r.baseVertexShader,r.advectionShader,r.gl),r.divergenceProgram=new SR7.A.fluiddynamics.Program(i.isFirefox?r.divergenceVertexShader:r.baseVertexShader,r.divergenceShader,r.gl),r.curlProgram=new SR7.A.fluiddynamics.Program(i.isFirefox?r.curlVertexShader:r.baseVertexShader,r.curlShader,r.gl),r.vorticityProgram=new SR7.A.fluiddynamics.Program(i.isFirefox?r.vorticityVertexShader:r.baseVertexShader,r.vorticityShader,r.gl),r.pressureProgram=new SR7.A.fluiddynamics.Program(i.isFirefox?r.pressureVertexShader:r.baseVertexShader,r.pressureShader,r.gl),r.gradienSubtractProgram=new SR7.A.fluiddynamics.Program(i.isFirefox?r.gradienSubtractVertexShader:r.baseVertexShader,r.gradientSubtractShader,r.gl),r.finalProgram=new SR7.A.fluiddynamics.Program(r.baseVertexShader,r.finalShader,r.gl),r.displayMaterial=new SR7.A.fluiddynamics.Material(r.baseVertexShader,r.displayShaderSource,r.gl),r.splat;const o=e(r.gl);i.colorFull?r.splat=(e,t,s,a,n,d)=>{r.splatProgram.bind(),r.gl.uniform1i(r.splatProgram.uniforms.uTarget,r.velocity.read.attach(0)),r.gl.uniform1f(r.splatProgram.uniforms.aspectRatio,r.canvas.width/r.canvas.height),r.gl.uniform1f(r.splatProgram.uniforms.pass,1),r.gl.uniform2f(r.splatProgram.uniforms.point,e,t),r.gl.uniform4f(r.splatProgram.uniforms.dxdy,s,a,0,0);let l=i.splatRadius;"off"==i.automateSel&&(l=Math.min(Math.max(Math.abs(s),Math.abs(a))/4e4*i.splatRadiusCache,i.splatRadiusCache)),r.gl.uniform1f(r.splatProgram.uniforms.radius,SR7.A.fluiddynamics.correctRadius(l/100,r.canvas)),o(r.velocity.write),r.velocity.swap(),r.gl.uniform1i(r.splatProgram.uniforms.uTarget,r.dye.read.attach(0)),r.gl.uniform1f(r.splatProgram.uniforms.pass,0),r.gl.uniform4f(r.splatProgram.uniforms.color,n[0]*n[3],n[1]*n[3],n[2]*n[3],n[3]),o(r.dye.write),r.dye.swap()}:r.splat=(e,t,s,a,n,d)=>{r.splatProgram.bind(),r.gl.uniform1i(r.splatProgram.uniforms.uTarget,r.velocity.read.attach(0)),r.gl.uniform1f(r.splatProgram.uniforms.aspectRatio,r.canvas.width/r.canvas.height),r.gl.uniform2f(r.splatProgram.uniforms.point,e,t),r.gl.uniform4f(r.splatProgram.uniforms.color,s,a,0,0),"mist"==i.automateSel&&(r.gl.uniform1f(r.splatProgram.uniforms.add,d?0:1),r.gl.uniform1f(r.splatProgram.uniforms.mousePower,30*i.mousePower));let l=i.splatRadius;"off"==i.automateSel&&(l=Math.min(Math.max(Math.abs(s),Math.abs(a))/4e4*i.splatRadiusCache,i.splatRadiusCache)),r.gl.uniform1f(r.splatProgram.uniforms.radius,SR7.A.fluiddynamics.correctRadius(l/100,r.canvas)),o(r.velocity.write),r.velocity.swap(),r.splatProgram2.bind(),r.gl.uniform1i(r.splatProgram2.uniforms.uTarget,r.dye.read.attach(0)),r.gl.uniform1f(r.splatProgram2.uniforms.aspectRatio,r.canvas.width/r.canvas.height),r.gl.uniform2f(r.splatProgram2.uniforms.point,e,t),r.gl.uniform1f(r.splatProgram2.uniforms.add,d?1:0),r.gl.uniform1f(r.splatProgram2.uniforms.uColorcount,i.allColorCount),r.gl.uniform1f(r.splatProgram2.uniforms.uColorChangeLenth,i.colorChangeLenth),r.gl.uniform1f(r.splatProgram2.uniforms.utime,r.utime),r.gl.uniform1f(r.splatProgram2.uniforms.uMistTime,r.utime/1e3),r.gl.uniform1f(r.splatProgram2.uniforms.radius,SR7.A.fluiddynamics.correctRadius(l/100,r.canvas)),o(r.dye.write),r.dye.swap()};let a=t.cw||1e3,n=t.ch||1200;switch(SR7.A.fluiddynamics.updateKeywords(r),SR7.A.fluiddynamics.resizeCanvas(r.canvas,r.settings.dprFluid,a,n,r.settings.dprOnMobile,r.settings.dprFluidMobile),SR7.A.fluiddynamics.initFramebuffers(r),"off"==i.followMouse&&"off"==i.followAMGen||SR7.A.fluiddynamics.initEventlisteners(t),i.automateSel){case"shoot":SR7.A.fluiddynamics.simShootingSetup(r);break;case"swipe":SR7.A.fluiddynamics.simSwipeSetup(r);break;case"collision":SR7.A.fluiddynamics.simCollisionSetup(r)}r.lastUpdateTime=Date.now(),r.colorUpdateTimer=0,r.bindedRender=()=>{SR7.A.fluiddynamics.update(t)}},initEventlisteners:e=>{let t=e.addOns.fluiddynamics;t.settings.lastfluidMouseMoveUpdateTime=0,t.pointersNum=0,"mGeneratorSimu"!=t.settings.followMouse&&"mGeneratorSimu"!=t.settings.followAMGen||(t.pointersNum=t.pointers.length-1),t.canvasRect=t.canvas.getBoundingClientRect(),t.canvas.addEventListener("mousemove",(function(t){SR7.A.fluiddynamics.listeners.mouse.move(t,e)})),t.canvas.addEventListener("mouseenter",(function(t){SR7.A.fluiddynamics.listeners.mouse.enter(t,e)})),t.canvas.addEventListener("wheel",(function(t){SR7.A.fluiddynamics.listeners.mouse.scroll(t,e)})),_tpt.is_mobile&&t.canvas.addEventListener("touchmove",(function(t){SR7.A.fluiddynamics.listeners.mouse.touchmove(t,e)}))},initFramebuffers:e=>{let t;t=_tpt.is_mobile?e.settings.qualityFluidMobile:e.settings.qualityFluid;let r=SR7.A.fluiddynamics.getResolution(128,e.gl),i=SR7.A.fluiddynamics.getResolution(t/100*1024,e.gl);const s=e.ext.halfFloatTexType,o=e.ext.formatRGBA,a=e.ext.formatRG,n=e.ext.formatR,d=e.ext.supportLinearFiltering?e.gl.LINEAR:e.gl.NEAREST;e.gl.disable(e.gl.BLEND),null==e.dye?e.dye=SR7.A.fluiddynamics.createDoubleFBO(i.width,i.height,o.internalFormat,o.format,s,d,e.gl):e.dye=SR7.A.fluiddynamics.resizeDoubleFBO(e,e.dye,i.width,i.height,o.internalFormat,o.format,s,d),null==e.velocity?e.velocity=SR7.A.fluiddynamics.createDoubleFBO(r.width,r.height,a.internalFormat,a.format,s,d,e.gl):e.velocity=SR7.A.fluiddynamics.resizeDoubleFBO(e,e.velocity,r.width,r.height,a.internalFormat,a.format,s,d),e.divergence=SR7.A.fluiddynamics.createFBO(r.width,r.height,n.internalFormat,n.format,s,e.gl.NEAREST,e.gl),e.curl=SR7.A.fluiddynamics.createFBO(r.width,r.height,n.internalFormat,n.format,s,e.gl.NEAREST,e.gl),e.pressure=SR7.A.fluiddynamics.createDoubleFBO(r.width,r.height,n.internalFormat,n.format,s,e.gl.NEAREST,e.gl)},resizeFBO:(t,r,i,s,o,a,n,d)=>{let l=SR7.A.fluiddynamics.createFBO(i,s,o,a,n,d,t.gl);t.copyProgram.bind(),t.gl.uniform1i(t.copyProgram.uniforms.uTexture,r.attach(0)),t.gl.disable(t.gl.BLEND);return e(t.gl)(l),l},resizeDoubleFBO:(e,t,r,i,s,o,a,n)=>(t.width==r&&t.height==i||(t.read=SR7.A.fluiddynamics.resizeFBO(e,t.read,r,i,s,o,a,n),t.write=SR7.A.fluiddynamics.createFBO(r,i,s,o,a,n,e.gl),t.width=r,t.height=i,t.texelSizeX=1/r,t.texelSizeY=1/i),t),updateKeywords:e=>{e.displayMaterial.setKeywords([])},refreshScene:e=>{e.addOns.fluiddynamics.settings},pointerPrototype:class{constructor(){this.id=-1,this.texcoordX=Math.random(),this.texcoordY=Math.random(),this.prevTexcoordX=0,this.prevTexcoordY=0,this.deltaX=0,this.deltaY=0,this.moved=!1,this.color=[0,0,0,1],this.add=!1,this.scrolled=!1,this.pathDestination=new THREE.Vector2,this.angle=Math.floor(360*Math.random()),SR7.A.fluiddynamics.setPathDestination(this.pathDestination,this.angle),this.pathDestinationVZ_X=1,this.pathDestinationVZ_Y=1}},step:t=>{let r=t.dt,i=t.gl,s=t.ext,o=t.settings;const a=e(i);i.disable(i.BLEND),t.curlProgram.bind(),i.uniform2f(t.curlProgram.uniforms.texelSize,t.velocity.texelSizeX,t.velocity.texelSizeY),i.uniform1i(t.curlProgram.uniforms.uVelocity,t.velocity.read.attach(0)),a(t.curl),t.vorticityProgram.bind(),i.uniform2f(t.vorticityProgram.uniforms.texelSize,t.velocity.texelSizeX,t.velocity.texelSizeY),i.uniform1i(t.vorticityProgram.uniforms.uVelocity,t.velocity.read.attach(0)),i.uniform1i(t.vorticityProgram.uniforms.uCurl,t.curl.attach(1)),i.uniform1f(t.vorticityProgram.uniforms.curl,o.curlVal),i.uniform1f(t.vorticityProgram.uniforms.dt,r),a(t.velocity.write),t.velocity.swap(),t.divergenceProgram.bind(),i.uniform2f(t.divergenceProgram.uniforms.texelSize,t.velocity.texelSizeX,t.velocity.texelSizeY),i.uniform1i(t.divergenceProgram.uniforms.uVelocity,t.velocity.read.attach(0)),a(t.divergence),t.clearProgram.bind(),i.uniform1i(t.clearProgram.uniforms.uTexture,t.pressure.read.attach(0)),i.uniform1f(t.clearProgram.uniforms.value,o.pressureDissipation),a(t.pressure.write),t.pressure.swap(),t.pressureProgram.bind(),i.uniform2f(t.pressureProgram.uniforms.texelSize,t.velocity.texelSizeX,t.velocity.texelSizeY),i.uniform1i(t.pressureProgram.uniforms.uDivergence,t.divergence.attach(0));for(let e=0;e<o.PRESSURE_ITERATIONS;e++)i.uniform1i(t.pressureProgram.uniforms.uPressure,t.pressure.read.attach(1)),a(t.pressure.write),t.pressure.swap();t.gradienSubtractProgram.bind(),i.uniform2f(t.gradienSubtractProgram.uniforms.texelSize,t.velocity.texelSizeX,t.velocity.texelSizeY),i.uniform1i(t.gradienSubtractProgram.uniforms.uPressure,t.pressure.read.attach(0)),i.uniform1i(t.gradienSubtractProgram.uniforms.uVelocity,t.velocity.read.attach(1)),a(t.velocity.write),t.velocity.swap(),t.advectionProgram.bind(),i.uniform2f(t.advectionProgram.uniforms.texelSize,t.velocity.texelSizeX,t.velocity.texelSizeY),s.supportLinearFiltering||i.uniform2f(t.advectionProgram.uniforms.dyeTexelSize,t.velocity.texelSizeX,t.velocity.texelSizeY);let n=t.velocity.read.attach(0);i.uniform1i(t.advectionProgram.uniforms.uVelocity,n),i.uniform1i(t.advectionProgram.uniforms.uSource,n),i.uniform1f(t.advectionProgram.uniforms.dt,r),i.uniform1f(t.advectionProgram.uniforms.dissipation,o.velocityDissipation),a(t.velocity.write),t.velocity.swap(),s.supportLinearFiltering||i.uniform2f(t.advectionProgram.uniforms.dyeTexelSize,t.dye.texelSizeX,t.dye.texelSizeY),i.uniform1i(t.advectionProgram.uniforms.uVelocity,t.velocity.read.attach(0)),i.uniform1i(t.advectionProgram.uniforms.uSource,t.dye.read.attach(1)),i.uniform1f(t.advectionProgram.uniforms.dissipation,o.densityDissipation),a(t.dye.write),t.dye.swap()},render:(e,t)=>{SR7.A.fluiddynamics.drawDisplay(e,t)},drawDisplay:(t,r)=>{let i=t.gl,s=t.settings,o=null==r?i.drawingBufferWidth:r.width,a=null==r?i.drawingBufferHeight:r.height;t.finalProgram.bind(),_tpt.is_mozilla&&i.uniform2f(t.finalProgram.uniforms.texelSize,1/o,1/a),i.uniform1i(t.finalProgram.uniforms.uTexture,t.dye.read.attach(0));const n=e(i);n(t.dye.write),t.dye.swap(),t.displayMaterial.bind(),_tpt.is_mozilla&&i.uniform2f(t.displayMaterial.uniforms.displayTexelSize,1/o,1/a),i.uniform1i(t.displayMaterial.uniforms.uTexture,t.dye.read.attach(0)),i.uniform4fv(t.displayMaterial.uniforms.color1,s.fd_color1),i.uniform4fv(t.displayMaterial.uniforms.color2,s.fd_color2),i.uniform4fv(t.displayMaterial.uniforms.color3,s.fd_color3),i.uniform1f(t.displayMaterial.uniforms.utime,t.utime),i.uniform1f(t.displayMaterial.uniforms.uColorChangeLenth,s.colorChangeLenth),n(r)},splatPointer:(e,t)=>{let r=6e3*t.deltaX,i=6e3*t.deltaY;e.gl.disable(e.gl.BLEND),e.splat(t.texcoordX,t.texcoordY,r,i,t.color,t.add)},update:e=>{let t=e.addOns.fluiddynamics,r=t.settings;if(!t.destroyed&&!t.paused){switch(t.frame=cancelAnimationFrame(t.frame),t.frame=requestAnimationFrame(t.bindedRender),t.utime>=1e3*Math.PI&&(t.utime=0,t.startTime=Date.now()),t.utime=(Date.now()-t.startTime)/1e3,"mist"!=r.automateSel?t.dt=SR7.A.fluiddynamics.calcDeltaTime(t):t.dt=.003*r.vecLength/100,SR7.A.fluiddynamics.resizeCanvas(t.canvas,t.settings.dprFluid,e.cw,e.ch,t.settings.dprOnMobile,t.settings.dprFluidMobile)&&(t.canvasRect=t.canvas.getBoundingClientRect(),SR7.A.fluiddynamics.initFramebuffers(t)),t.updateColorFunction(t),r.automateSel){case"shoot":SR7.A.fluiddynamics.simShooting(t,r.simuWait,r.simuLength,r.simuRadius);break;case"circle":SR7.A.fluiddynamics.simCircle(t,r.simuWait,r.simuLength,r.simuRadius);break;case"swipe":SR7.A.fluiddynamics.simSwipe(t,r.simuWait,r.simuLength,r.simuRadius);break;case"collision":SR7.A.fluiddynamics.simCollision(t,r.simuWait,r.simuLength,r.simuRadius);break;case"mist":SR7.A.fluiddynamics.simMist(t,r.simuWait,r.simuLength,r.simuRadius);break;case"bounce":SR7.A.fluiddynamics.simBounce(t,r.simuWait,r.simuLength,r.simuRadius)}SR7.A.fluiddynamics.applyInputs(t),SR7.A.fluiddynamics.step(t),SR7.A.fluiddynamics.render(t,null)}},applyInputs:e=>{e.pointers.forEach((t=>{t.moved&&(t.moved=!1,SR7.A.fluiddynamics.splatPointer(e,t))}))},destroy:e=>{let t=e.addOns.fluiddynamics;t.destroyed=!0,gl.clearColor(0,0,0,0),gl.clear(gl.COLOR_BUFFER_BIT),t.frame=cancelAnimationFrame(t.frame)},getUniforms:(e,t)=>{let r=[],i=t.getProgramParameter(e,t.ACTIVE_UNIFORMS);for(let s=0;s<i;s++){let i=t.getActiveUniform(e,s).name;r[i]=t.getUniformLocation(e,i)}return r},simShootingSetup:e=>{const t=Math.random()-.5,r=Math.random()-.5,i=t/Math.sqrt(t*t+r*r),s=r/Math.sqrt(t*t+r*r);e.settings.vec2.x=2*i,e.settings.vec2.y=2*s,e.pointers[0].moved=!1,e.pointers[0].prevTexcoordX=e.pointers[0].texcoordX,e.pointers[0].prevTexcoordY=e.pointers[0].texcoordY,e.pointers[0].texcoordX=.5,e.pointers[0].texcoordY=.5,e.pointers[0].deltaX=0,e.pointers[0].deltaY=0},simShooting:(e,t,r,i)=>{e.settings.COUNTER<r&&(e.pointers[0].moved=!0,e.pointers[0].prevTexcoordX=e.pointers[0].texcoordX,e.pointers[0].prevTexcoordY=e.pointers[0].texcoordY,e.pointers[0].texcoordX+=e.settings.vec2.x*e.settings.simuPower*10/e.canvas.width,e.pointers[0].texcoordY+=e.settings.vec2.y*e.settings.simuPower*10/e.canvas.height,e.pointers[0].deltaX=(e.pointers[0].texcoordX-e.pointers[0].prevTexcoordX)*e.settings.simuPower*10,e.pointers[0].deltaY=(e.pointers[0].texcoordY-e.pointers[0].prevTexcoordY)*e.settings.simuPower*10,e.settings.COUNTER++),e.settings.COUNTER>=r&&e.settings.COUNTER<r+t&&(SR7.A.fluiddynamics.simShootingSetup(e),e.settings.COUNTER++),e.settings.COUNTER>=r+t&&(e.settings.COUNTER=0)},simCircle:(e,t,r,i)=>{i/=100;var s=e.settings.COUNTER/100*Math.PI*2*r/50,o=Math.min(e.canvas.width,e.canvas.height)*i,a=e.canvas.width/2+Math.sin(s)*o/2,n=e.canvas.height/2+Math.cos(s)*o/2;e.pointers[0].moved=!0,e.pointers[0].prevTexcoordX=e.pointers[0].texcoordX,e.pointers[0].prevTexcoordY=e.pointers[0].texcoordY,e.pointers[0].texcoordX=a/e.canvas.width,e.pointers[0].texcoordY=n/e.canvas.height,e.pointers[0].deltaX=(e.pointers[0].texcoordX-e.pointers[0].prevTexcoordX)*e.settings.simuPower*1.5,e.pointers[0].deltaY=(e.pointers[0].texcoordY-e.pointers[0].prevTexcoordY)*e.settings.simuPower*1.5,e.settings.COUNTER++},simSwipeSetup:e=>{var t=.1;switch(e.settings.directionChooser){case"lr":e.settings.vec2.set(1,0),e.settings.startPos2.set(t,.5);break;case"rl":e.settings.vec2.set(-1,0),e.settings.startPos2.set(.9,.5);break;case"bt":e.settings.vec2.set(0,1),e.settings.startPos2.set(.5,t);break;case"tb":e.settings.vec2.set(0,-1),e.settings.startPos2.set(.5,.9);break;case"bltr":e.settings.vec2.set(e.canvas.width,e.canvas.height),e.settings.startPos2.set(t,t);break;case"trbl":e.settings.vec2.set(-e.canvas.width,-e.canvas.height),e.settings.startPos2.set(.9,.9);break;case"brtl":e.settings.vec2.set(-e.canvas.width,e.canvas.height),e.settings.startPos2.set(.9,t);break;case"tlbr":e.settings.vec2.set(e.canvas.width,-e.canvas.height),e.settings.startPos2.set(t,.9)}e.settings.vec2.setLength(1),e.pointers[0].moved=!1,e.pointers[0].prevTexcoordX=e.pointers[0].texcoordX,e.pointers[0].prevTexcoordY=e.pointers[0].texcoordY,e.pointers[0].texcoordX=e.settings.startPos2.x,e.pointers[0].texcoordY=e.settings.startPos2.y,e.pointers[0].deltaX=0,e.pointers[0].deltaY=0},simSwipe:(e,t,r,i)=>{e.settings.COUNTER<r&&(e.pointers[0].moved=!0,e.pointers[0].prevTexcoordX=e.pointers[0].texcoordX,e.pointers[0].prevTexcoordY=e.pointers[0].texcoordY,e.pointers[0].texcoordX+=10*e.settings.vec2.x/e.canvas.width,e.pointers[0].texcoordY+=10*e.settings.vec2.y/e.canvas.height,e.pointers[0].deltaX=(e.pointers[0].texcoordX-e.pointers[0].prevTexcoordX)*e.settings.simuPower*10,e.pointers[0].deltaY=(e.pointers[0].texcoordY-e.pointers[0].prevTexcoordY)*e.settings.simuPower*10,e.settings.COUNTER++),e.settings.COUNTER>=r&&e.settings.COUNTER<r+t&&(SR7.A.fluiddynamics.simSwipeSetup(e),e.settings.COUNTER++),e.settings.COUNTER>=r+t&&(e.settings.COUNTER=0)},simCollisionSetup:e=>{var t=.1;switch(e.settings.colDirectionChooser){case"lr":e.settings.vec2.set(1,0),e.settings.startPos2.set(t,.5),e.settings.startPosNegate.set(.9,.5);break;case"tb":e.settings.vec2.set(0,1),e.settings.startPos2.set(.5,t),e.settings.startPosNegate.set(.5,.9);break;case"trbl":e.settings.vec2.set(e.canvas.width,e.canvas.height),e.settings.startPos2.set(t,t),e.settings.startPosNegate.set(.9,.9);break;case"tlbr":e.settings.vec2.set(-e.canvas.width,e.canvas.height),e.settings.startPos2.set(.9,t),e.settings.startPosNegate.set(t,.9)}e.settings.vec2.setLength(1),e.pointers[0].moved=!1,e.pointers[0].prevTexcoordX=e.pointers[0].texcoordX,e.pointers[0].prevTexcoordY=e.pointers[0].texcoordY,e.pointers[0].texcoordX=e.settings.startPos2.x,e.pointers[0].texcoordY=e.settings.startPos2.y,e.pointers[0].deltaX=0,e.pointers[0].deltaY=0,e.settings.vec2.setLength(1),e.pointers[1].moved=!1,e.pointers[1].prevTexcoordX=e.pointers[1].texcoordX,e.pointers[1].prevTexcoordY=e.pointers[1].texcoordY,e.pointers[1].texcoordX=e.settings.startPosNegate.x,e.pointers[1].texcoordY=e.settings.startPosNegate.y,e.pointers[1].deltaX=0,e.pointers[1].deltaY=0},simCollision:(e,t,r,i)=>{e.settings.COUNTER<r&&(e.pointers[0].moved=!0,e.pointers[0].prevTexcoordX=e.pointers[0].texcoordX,e.pointers[0].prevTexcoordY=e.pointers[0].texcoordY,e.pointers[0].texcoordX+=10*e.settings.vec2.x/e.canvas.width,e.pointers[0].texcoordY+=10*e.settings.vec2.y/e.canvas.height,e.pointers[0].deltaX=(e.pointers[0].texcoordX-e.pointers[0].prevTexcoordX)*e.settings.simuPower*10,e.pointers[0].deltaY=(e.pointers[0].texcoordY-e.pointers[0].prevTexcoordY)*e.settings.simuPower*10,e.pointers[1].moved=!0,e.pointers[1].prevTexcoordX=e.pointers[0].texcoordX,e.pointers[1].prevTexcoordY=e.pointers[0].texcoordY,e.pointers[1].texcoordX+=-10*e.settings.vec2.x/e.canvas.width,e.pointers[1].texcoordY+=-10*e.settings.vec2.y/e.canvas.height,e.pointers[1].deltaX=-(e.pointers[0].texcoordX-e.pointers[0].prevTexcoordX)*e.settings.simuPower*10,e.pointers[1].deltaY=-(e.pointers[0].texcoordY-e.pointers[0].prevTexcoordY)*e.settings.simuPower*10,e.settings.COUNTER++),e.settings.COUNTER>=r&&e.settings.COUNTER<r+t&&(SR7.A.fluiddynamics.simCollisionSetup(e),e.settings.COUNTER++),e.settings.COUNTER>=r+t&&(e.settings.COUNTER=0)},simBounce:(e,t,r,i)=>{e.settings.vec2.set(1,1),e.settings.COUNTER<r?(e.settings.COUNTER++,(e.pointers[0].texcoordX<0||e.pointers[0].texcoordX>1)&&(e.pointers[0].pathDestinationVZ_X*=-1),(e.pointers[0].texcoordY<0||e.pointers[0].texcoordY>1)&&(e.pointers[0].pathDestinationVZ_Y*=-1),e.pointers[0].moved=!0,e.pointers[0].prevTexcoordX=e.pointers[0].texcoordX,e.pointers[0].prevTexcoordY=e.pointers[0].texcoordY,e.pointers[0].texcoordX+=e.settings.vec2.x*r/5*e.pointers[0].pathDestinationVZ_X/e.canvas.width,e.pointers[0].texcoordY+=e.settings.vec2.y*r/5*e.pointers[0].pathDestinationVZ_Y/e.canvas.height,e.pointers[0].deltaX=(e.pointers[0].texcoordX-e.pointers[0].prevTexcoordX)*e.settings.simuPower*10,e.pointers[0].deltaY=(e.pointers[0].texcoordY-e.pointers[0].prevTexcoordY)*e.settings.simuPower*10):e.settings.COUNTER=0},simMist:(e,t,r,i)=>{for(let t=0;t<e.pointers.length-1;t++)if(e.settings.COUNTER<r){e.settings.COUNTER++;var s=Math.ceil(e.pointers.length/2)+2;t<=s&&((e.pointers[t].texcoordX<0||e.pointers[t].texcoordX>1)&&(e.pointers[t].pathDestinationVZ_X*=-1),(e.pointers[t].texcoordY<0||e.pointers[t].texcoordY>1)&&(e.pointers[t].pathDestinationVZ_Y*=-1),e.pointers[t].moved=!0,e.pointers[t].add=!0,e.pointers[t].prevTexcoordX=e.pointers[t].texcoordX,e.pointers[t].prevTexcoordY=e.pointers[t].texcoordY,e.pointers[t].texcoordX+=e.pointers[t].pathDestination.x*r/8*e.pointers[t].pathDestinationVZ_X/e.canvas.width,e.pointers[t].texcoordY=0,e.pointers[t].deltaX=(e.pointers[t].texcoordX-e.pointers[t].prevTexcoordX)*e.settings.simuPower/50,e.pointers[t].deltaY=e.settings.simuPower/50),t>s&&(e.pointers[t].moved=!0,e.pointers[t].add=!0,e.pointers[t].prevTexcoordX=e.pointers[t].texcoordX,e.pointers[t].prevTexcoordY=e.pointers[t].texcoordY,e.pointers[t].texcoordX=e.pointers[t-s].texcoordX,e.pointers[t].texcoordY=e.pointers[t-s].texcoordY,e.pointers[t].deltaX=e.pointers[t-s].deltaX,e.pointers[t].deltaY=e.pointers[t-s].deltaY)}else e.settings.COUNTER=0,SR7.A.fluiddynamics.setPathDestination(e.pointers[t].pathDestination,e.pointers[t].angle)},setPathDestination:(e,t)=>{var r=60*Math.random()-30+t;e.set(Math.cos(r*Math.PI/180),Math.sin(r*Math.PI/180))},createProgram:(e,t,r)=>{let i=r.createProgram();return r.attachShader(i,e),r.attachShader(i,t),r.linkProgram(i),r.getProgramParameter(i,r.LINK_STATUS)||console.trace(r.getProgramInfoLog(i)),i},resizeCanvas:(e,t,r,i,s,o)=>{let a="auto"==t||"0"==t?window.devicePixelRatio:Math.min(window.devicePixelRatio,parseInt(t));if(_tpt.is_mobile&&s&&"auto"!==o&&(a=Math.min(a,parseInt(o))),e.width!==Math.floor(r*a)||e.height!==Math.floor(i*a)){return e.width=Math.floor(r*a),e.height=Math.floor(i*a),e.style.width=r+"px",e.style.height=i+"px",e.getContext("webgl2",{alpha:!0,depth:!1,stencil:!1,antialias:!1,preserveDrawingBuffer:!1}).viewport(0,0,e.width,e.height),!0}return!1},hashCode:e=>{if(0==e.length)return 0;let t=0;for(let r=0;r<e.length;r++)t=(t<<5)-t+e.charCodeAt(r),t|=0;return t},correctRadius:(e,t)=>{let r=t.width/t.height;return r>1&&(e*=r),e},getResolution:(e,t)=>{let r=t.drawingBufferWidth/t.drawingBufferHeight;r<1&&(r=1/r);let i=Math.round(e),s=Math.round(e*r);return t.drawingBufferWidth>t.drawingBufferHeight?{width:s,height:i}:{width:i,height:s}},HSVtoRGB:e=>{let t=6*e,r=Math.floor(t),i=t-r,s=1-i,o=i;switch(r%6){case 0:return[1,o,0,1];case 1:return[s,1,0,1];case 2:return[0,1,o,1];case 3:return[0,s,1,1];case 4:return[o,0,1,1];case 5:return[1,0,1,1]}},wrap:(e,t,r)=>{let i=r-t;return 0==i?t:(e-t)%i+t},calcDeltaTime:e=>{let t=Date.now(),r=(t-e.lastUpdateTime)/1e3;return r=Math.min(r,.016666),e.lastUpdateTime=t,r},createDoubleFBO:(e,t,r,i,s,o,a)=>{let n=SR7.A.fluiddynamics.createFBO(e,t,r,i,s,o,a),d=SR7.A.fluiddynamics.createFBO(e,t,r,i,s,o,a);return{width:e,height:t,texelSizeX:n.texelSizeX,texelSizeY:n.texelSizeY,get read(){return n},set read(e){n=e},get write(){return d},set write(e){d=e},swap(){let e=n;n=d,d=e}}},createFBO:(e,t,r,i,s,o,a)=>{a.activeTexture(a.TEXTURE0);let n=a.createTexture();a.bindTexture(a.TEXTURE_2D,n),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,o),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,o),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texImage2D(a.TEXTURE_2D,0,r,e,t,0,i,s,null);let d=a.createFramebuffer();return a.bindFramebuffer(a.FRAMEBUFFER,d),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,n,0),a.viewport(0,0,e,t),a.clear(a.COLOR_BUFFER_BIT),{texture:n,fbo:d,width:e,height:t,texelSizeX:1/e,texelSizeY:1/t,attach:e=>(a.activeTexture(a.TEXTURE0+e),a.bindTexture(a.TEXTURE_2D,n),e)}},getWebGLContext:e=>{const t={alpha:!0,depth:!1,stencil:!1,antialias:!1,preserveDrawingBuffer:!1};let r=e.getContext("webgl2",t);const i=!!r;let s,o;i||(r=e.getContext("webgl",t)||e.getContext("experimental-webgl",t)),i?(r.getExtension("EXT_color_buffer_float"),o=r.getExtension("OES_texture_float_linear")):(s=r.getExtension("OES_texture_half_float"),o=r.getExtension("OES_texture_half_float_linear")),r.clearColor(0,0,0,1);const a=i?r.HALF_FLOAT:s.HALF_FLOAT_OES;let n,d,l;return i?(n=SR7.A.fluiddynamics.getSupportedFormat(r,r.RGBA16F,r.RGBA,a),d=SR7.A.fluiddynamics.getSupportedFormat(r,r.RG16F,r.RG,a),l=SR7.A.fluiddynamics.getSupportedFormat(r,r.R16F,r.RED,a)):(n=SR7.A.fluiddynamics.getSupportedFormat(r,r.RGBA,r.RGBA,a),d=SR7.A.fluiddynamics.getSupportedFormat(r,r.RGBA,r.RGBA,a),l=SR7.A.fluiddynamics.getSupportedFormat(r,r.RGBA,r.RGBA,a)),{gl:r,ext:{formatRGBA:n,formatRG:d,formatR:l,halfFloatTexType:a,supportLinearFiltering:o}}},getSupportedFormat:(e,t,r,i)=>{if(!SR7.A.fluiddynamics.supportRenderTextureFormat(e,t,r,i))switch(t){case e.R16F:return SR7.A.fluiddynamics.getSupportedFormat(e,e.RG16F,e.RG,i);case e.RG16F:return SR7.A.fluiddynamics.getSupportedFormat(e,e.RGBA16F,e.RGBA,i);default:return null}return{internalFormat:t,format:r}},supportRenderTextureFormat:(e,t,r,i)=>{let s=e.createTexture();e.bindTexture(e.TEXTURE_2D,s),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texImage2D(e.TEXTURE_2D,0,t,4,4,0,r,i,null);let o=e.createFramebuffer();return e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,s,0),e.checkFramebufferStatus(e.FRAMEBUFFER)==e.FRAMEBUFFER_COMPLETE},resetMaxOpacity:(e,t)=>{e[0]*=t,e[1]*=t,e[2]*=t,e[3]>t&&(e[3]=t)},Material:class{constructor(e,t,r){this.vertexShader=e,this.fragmentShaderSource=t,this.programs=[],this.activeProgram=null,this.uniforms=[],this.gl=r}setKeywords(e){let t=0;for(let r=0;r<e.length;r++)t+=hashCode(e[r]);let r=this.programs[t];null==r&&(r=SR7.A.fluiddynamics.createProgram(this.vertexShader,this.fragmentShaderSource,this.gl),this.programs[t]=r),r!=this.activeProgram&&(this.uniforms=SR7.A.fluiddynamics.getUniforms(r,this.gl),this.activeProgram=r)}bind(){this.gl.useProgram(this.activeProgram)}},Program:class{constructor(e,t,r){this.gl=r,this.uniforms={},this.program=SR7.A.fluiddynamics.createProgram(e,t,r),this.uniforms=SR7.A.fluiddynamics.getUniforms(this.program,r)}bind(){this.gl.useProgram(this.program)}}};const e=e=>(e.bindBuffer(e.ARRAY_BUFFER,e.createBuffer()),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),e.STATIC_DRAW),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,e.createBuffer()),e.bufferData(e.ELEMENT_ARRAY_BUFFER,new Uint16Array([0,1,2,0,2,3]),e.STATIC_DRAW),e.vertexAttribPointer(0,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(0),(t,r=!1)=>{null==t?(e.viewport(0,0,e.drawingBufferWidth,e.drawingBufferHeight),e.bindFramebuffer(e.FRAMEBUFFER,null)):(e.viewport(0,0,t.width,t.height),e.bindFramebuffer(e.FRAMEBUFFER,t.fbo)),r&&(e.clearColor(0,0,0,1),e.clear(e.COLOR_BUFFER_BIT)),e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)});_tpt.R??={},_tpt.R.fd_Fluid=_tpt.extend?_tpt.extend(_tpt.R.fd_Fluid,{status:2,version:"1.0"}):{status:2,version:"1.0"},window.dispatchEvent(new CustomEvent("SR7FluiddynamicsFluidLoaded"))}();
!function(){"use strict";window.SR7??={},window._tpt??={},SR7.A??={},SR7.F??={},SR7.D??={},void 0===(SR7.A.fluiddynamics?.shaders??void 0)&&(SR7.A.fluiddynamics={...SR7.A.fluiddynamics,shaders:{baseVertexShader:()=>"\n                precision highp float;\n\n                attribute vec2 aPosition;\n                varying vec2 vUv;\n                varying vec2 vL;\n                varying vec2 vR;\n                varying vec2 vT;\n                varying vec2 vB;\n                uniform vec2 texelSize;\n\n                void main () {\n                    vUv = aPosition * 0.5 + 0.5;\n                    vL = vUv - vec2(texelSize.x, 0.0);\n                    vR = vUv + vec2(texelSize.x, 0.0);\n                    vT = vUv + vec2(0.0, texelSize.y);\n                    vB = vUv - vec2(0.0, texelSize.y);\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n                }\n            ",copyShader:()=>"\n                precision mediump float;\n                precision mediump sampler2D;\n\n                varying highp vec2 vUv;\n                uniform sampler2D uTexture;\n\n                void main () {\n                    gl_FragColor = texture2D(uTexture, vUv);\n                }\n            ",clearShader:()=>"\n                precision mediump float;\n                precision mediump sampler2D;\n\n                varying highp vec2 vUv;\n                uniform sampler2D uTexture;\n                uniform float value;\n\n                void main () {\n                    gl_FragColor = value * texture2D(uTexture, vUv);\n                }\n            ",finalShader:()=>"\n                precision mediump float;\n                precision mediump sampler2D;\n\n                varying highp vec2 vUv;\n                uniform sampler2D uTexture;\n\n                void main () {\n                    vec4 c = texture2D(uTexture, vUv);\n\n                    float a = max(c.r, max(c.g, c.b));\n                    gl_FragColor = vec4(c.xyz, a);\n                }\n            ",displayShaderSource:e=>{let n="\n                    precision highp float;\n                    precision highp sampler2D;\n\n                    varying vec2 vUv;\n                    varying vec2 vL;\n                    varying vec2 vR;\n                    varying vec2 vT;\n                    varying vec2 vB;\n                    uniform sampler2D uTexture;\n                    uniform sampler2D uDithering;\n                    uniform vec2 ditherScale;\n\n                    uniform float utime;\n                    uniform float uColorChangeLenth;\n\n                    uniform vec4 color1;\n                    uniform vec4 color2;\n                    uniform vec4 color3;\n                    \n                    void main () {\n                        vec4 c = texture2D(uTexture, vUv);\n                        vec4 black = vec4(0.0, 0.0, 0.0, c.a);\n\n                        //see how light color1 is: (range 0.0 - 1.0)\n                        float light = max(color1.r, max(color1.g, color1.b));\n\n                        vec4 interpolatedColor = vec4(1.0);\n                        //INTERPOLATEDCOLOR HERE\n\n                        //COLORFULL HERE\n                        \n                        gl_FragColor = c;\n                    }\n                ";if(!e.colorFull)if("timed"==e.colorChangeType)switch(e.allColorCount){case 0:n=n.replace("//INTERPOLATEDCOLOR HERE","\n                                    interpolatedColor = color1;\n                                    c -= 1.0 - interpolatedColor;\n                \n                                    if(light == 0.0){\n                                        c = black;\n                                    }\n                                ");break;case 1:n=n.replace("//INTERPOLATEDCOLOR HERE","\n                                    float t = sin(utime * 1.0 / uColorChangeLenth);\n                                    t = (t+1.0) * 0.5;\n                                    interpolatedColor = mix(color1, color2, smoothstep(0.0, 1.0, t));\n                \n                                    c -= 1.0 - interpolatedColor;\n                                ");break;case 2:n=n.replace("//INTERPOLATEDCOLOR HERE","\n                                    //float t = sin(utime * uColorChangeLenth * 2.0/3.0);\n                                    //t = (t + 1.0) * 0.5;\n                                    float t = utime * 1.0 / uColorChangeLenth;\n                                    t = t * 2.0/3.0 - 1.0 * floor((t * 2.0/3.0) / 1.0);\n                \n                                    float step1 = 1.0 / 3.0;\n                                    float step2 = 2.0 / 3.0;\n                \n                                    if (t < step1) {\n                                        interpolatedColor = mix(color1, color2, smoothstep(0.0, step1, t));\n                                    } else if (t < step2) {\n                                        interpolatedColor = mix(color2, color3, smoothstep(step1, step2, t));\n                                    } else {\n                                        interpolatedColor = mix(color3, color1, smoothstep(step2, 1.0, t));\n                                    }\n                \n                                    c -= 1.0 - interpolatedColor;\n                                ")}else n=n.replace("//INTERPOLATEDCOLOR HERE","\n                            //float t = sin(utime * 1.0 / uColorChangeLenth);\n                            //t = (t+1.0) * 0.5;\n                            interpolatedColor = mix(color2, color1, smoothstep(0.3, 1.0, c.a));\n            \n                            c -= 1.0 - interpolatedColor;\n                        ");return n},splatShader:e=>{let n="\n                    precision highp float;\n                    precision highp sampler2D;\n\n                    varying vec2 vUv;\n                    uniform sampler2D uTarget;\n                    uniform float aspectRatio;\n                    uniform vec4 color;\n                    uniform vec4 dxdy;\n                    uniform vec2 point;\n                    uniform float radius;\n                    uniform float utime;\n                    uniform float pass;\n                    uniform float add;\n                    uniform float mousePower;\n\n                    void main () {\n                        vec2 p = vUv - point.xy;\n                        p.x *= aspectRatio;\n                        vec4 switchVal = color;\n\n                        if(pass == 1.0){\n                            switchVal = dxdy;\n                        }\n\n                        if(add == 1.0){\n                            switchVal = switchVal * mousePower;\n                        }\n\n                        vec4 splat = vec4(0.0);\n\n                        //GLOW HERE\n                        \n                        if(pass == 0.0){\n                            splat.a = 1.0;\n                        }\n\n                        vec4 base = texture2D(uTarget, vUv);\n\n                        gl_FragColor = splat + base;\n                    }\n                ";return n=e.glow?n.replace("//GLOW HERE","\n                        splat = 1.0 / (1.0 + dot(p, p) / (radius * radius * 1000.0)) * switchVal;\n                    "):n.replace("//GLOW HERE","\n                        splat = exp(-dot(p, p) / radius) * switchVal;\n                    "),n},splatShader2:e=>{let n="\n                    precision highp float;\n                    precision highp sampler2D;\n            \n                    varying vec2 vUv;\n                    uniform sampler2D uTarget;\n                    uniform float aspectRatio;\n                    uniform float utime;\n                    uniform vec2 point;\n                    uniform float radius;\n                    uniform float uColorChangeLenth;\n                    uniform float uMistTime;\n                    uniform float add;\n            \n                    //PRE MAIN\n                    \n                    void main () {\n                        vec2 uv = vUv - point.xy;\n                        uv.x *= aspectRatio;\n                        \n                        vec2 p = vUv - point.xy;\n                        p.x *= aspectRatio;\n            \n                        //NOISE HERE\n            \n                        //INTERPOLATEDCOLOR HERE\n                        vec4 interpolatedColor = vec4(1.0);\n            \n                        //OUTPUT HERE\n                    }\n                ";return"mist"==e.automateSel?(n=n.replace("//PRE MAIN","\n                        float hash(float n) {\n                            return fract(sin(n) * 43758.5453);\n                        }\n                        \n                        float smoothsteper(float edge0, float edge1, float x) {\n                            float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n                            return t * t * (3.0 - 2.0 * t);\n                        }\n        \n                        float perlinNoise(vec2 p) {\n                            vec2 i = floor(p);\n                            vec2 f = fract(p);\n        \n                            // Calculate the four corners of the cell\n                            float a = hash(dot(i, vec2(37.0, 17.0)));\n                            float b = hash(dot(i + vec2(1.0, 0.0), vec2(37.0, 17.0)));\n                            float c = hash(dot(i + vec2(0.0, 1.0), vec2(37.0, 17.0)));\n                            float d = hash(dot(i + vec2(1.0, 1.0), vec2(37.0, 17.0)));\n        \n                            // Smoothly interpolate gradients\n                            vec2 u = f * f * (3.0 - 2.0 * f);\n                            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n                        }\n                    "),n=n.replace("//NOISE HERE","\n                        float timeFactor = utime * 0.1;\n                        float timeV = perlinNoise(vec2(timeFactor * 0.1));\n                        float timeF = perlinNoise(vec2(timeFactor * 3.5));\n        \n                        float noiseValue = (perlinNoise((uv - vec2(timeV, timeF)) * 10.0 + timeFactor) + 1.0) * 0.5;\n        \n                        vec4 noise = vec4(noiseValue);\n                        noise.x -= 0.5;\n                        noise.y -= 0.5;\n                        noise.z -= 0.5;\n                        noise.a = 0.0;\n                        noise *= 0.001;\n                    "),n=n.replace("//OUTPUT HERE","\n                        vec4 limitedOutput = vec4(0.0);\n                        vec4 splat = vec4(0.0);\n                        vec4 base = vec4(0.0);\n        \n                        if(add == 1.0){\n                            p.x = 0.0;\n                            splat = exp(-dot(p, p) / radius * noiseValue) * interpolatedColor;\n                            base = texture2D(uTarget, vUv);\n                            limitedOutput = min(splat + base + noise, interpolatedColor);\n                        }\n                        else{\n                            splat = exp(-dot(p, p) / radius) * interpolatedColor;\n                            base = texture2D(uTarget, vUv);\n                            limitedOutput = min(splat + base, interpolatedColor);\n                        }\n                        \n                        gl_FragColor = limitedOutput;\n                        //gl_FragColor = vec4(noise, 1.0);\n                    ")):n=e.glow?n.replace("//OUTPUT HERE","\n                            vec4 splat = 1.0 / (1.0 + dot(p, p) / (radius * radius * 1000.0)) * interpolatedColor;\n                            vec4 base = texture2D(uTarget, vUv);\n                            vec4 limitedOutput = min(splat + base, interpolatedColor * 1.25);\n                            gl_FragColor = limitedOutput;\n                        "):n.replace("//OUTPUT HERE","\n                            vec4 splat = exp(-dot(p, p) / radius) * interpolatedColor;\n                            vec4 base = texture2D(uTarget, vUv);\n                            vec4 limitedOutput = min(splat + base, interpolatedColor * 1.25);\n                            gl_FragColor = limitedOutput;\n                        "),n},advectionShader:()=>"\n                precision highp float;\n                precision highp sampler2D;\n\n                varying vec2 vUv;\n                uniform sampler2D uVelocity;\n                uniform sampler2D uSource;\n                uniform vec2 dyeTexelSize;\n                uniform vec2 texelSize;\n                uniform float dt;\n                uniform float dissipation;\n\n                vec4 bilerp (sampler2D sam, vec2 uv, vec2 tsize) {\n                    vec2 st = uv / tsize - 0.5;\n\n                    vec2 iuv = floor(st);\n                    vec2 fuv = fract(st);\n\n                    vec4 a = texture2D(sam, (iuv + vec2(0.5, 0.5)) * tsize);\n                    vec4 b = texture2D(sam, (iuv + vec2(1.5, 0.5)) * tsize);\n                    vec4 c = texture2D(sam, (iuv + vec2(0.5, 1.5)) * tsize);\n                    vec4 d = texture2D(sam, (iuv + vec2(1.5, 1.5)) * tsize);\n\n                    return mix(mix(a, b, fuv.x), mix(c, d, fuv.x), fuv.y);\n                }\n\n                void main () {\n                #ifdef MANUAL_FILTERING\n                    vec2 coord = vUv - dt * bilerp(uVelocity, vUv, texelSize).xy * texelSize;\n                    vec4 result = bilerp(uSource, coord, dyeTexelSize);\n                #else\n                    vec2 coord = vUv - dt * texture2D(uVelocity, vUv).xy * texelSize;\n                    vec4 result = texture2D(uSource, coord);\n                #endif\n                    float decay = 1.0 + dissipation * dt;\n                    gl_FragColor = result / decay;\n                }\n            ",divergenceShader:()=>"\n                precision mediump float;\n                precision mediump sampler2D;\n\n                varying highp vec2 vUv;\n                varying highp vec2 vL;\n                varying highp vec2 vR;\n                varying highp vec2 vT;\n                varying highp vec2 vB;\n                uniform sampler2D uVelocity;\n\n                void main () {\n                    float L = texture2D(uVelocity, vL).x;\n                    float R = texture2D(uVelocity, vR).x;\n                    float T = texture2D(uVelocity, vT).y;\n                    float B = texture2D(uVelocity, vB).y;\n\n                    vec2 C = texture2D(uVelocity, vUv).xy;\n                    if (vL.x < 0.0) { L = -C.x; }\n                    if (vR.x > 1.0) { R = -C.x; }\n                    if (vT.y > 1.0) { T = -C.y; }\n                    if (vB.y < 0.0) { B = -C.y; }\n\n                    float div = 0.5 * (R - L + T - B);\n                    gl_FragColor = vec4(div, 0.0, 0.0, 1.0);\n                }\n            ",curlShader:()=>"\n                precision mediump float;\n                precision mediump sampler2D;\n\n                varying highp vec2 vUv;\n                varying highp vec2 vL;\n                varying highp vec2 vR;\n                varying highp vec2 vT;\n                varying highp vec2 vB;\n                uniform sampler2D uVelocity;\n\n                void main () {\n                    float L = texture2D(uVelocity, vL).y;\n                    float R = texture2D(uVelocity, vR).y;\n                    float T = texture2D(uVelocity, vT).x;\n                    float B = texture2D(uVelocity, vB).x;\n                    float vorticity = R - L - T + B;\n                    gl_FragColor = vec4(0.5 * vorticity, 0.0, 0.0, 1.0);\n                }\n            ",vorticityShader:()=>"\n                precision highp float;\n                precision highp sampler2D;\n\n                varying vec2 vUv;\n                varying vec2 vL;\n                varying vec2 vR;\n                varying vec2 vT;\n                varying vec2 vB;\n                uniform sampler2D uVelocity;\n                uniform sampler2D uCurl;\n                uniform float curl;\n                uniform float dt;\n\n                void main () {\n                    float L = texture2D(uCurl, vL).x;\n                    float R = texture2D(uCurl, vR).x;\n                    float T = texture2D(uCurl, vT).x;\n                    float B = texture2D(uCurl, vB).x;\n                    float C = texture2D(uCurl, vUv).x;\n\n                    vec2 force = 0.5 * vec2(abs(T) - abs(B), abs(R) - abs(L));\n                    force /= length(force) + 0.0001;\n                    force *= curl * C;\n                    force.y *= -1.0;\n\n                    vec2 velocity = texture2D(uVelocity, vUv).xy;\n                    velocity += force * dt;\n                    velocity = min(max(velocity, -1000.0), 1000.0);\n                    gl_FragColor = vec4(velocity, 0.0, 1.0);\n                }\n            ",pressureShader:()=>"\n                precision mediump float;\n                precision mediump sampler2D;\n\n                varying highp vec2 vUv;\n                varying highp vec2 vL;\n                varying highp vec2 vR;\n                varying highp vec2 vT;\n                varying highp vec2 vB;\n                uniform sampler2D uPressure;\n                uniform sampler2D uDivergence;\n\n                void main () {\n                    float L = texture2D(uPressure, vL).x;\n                    float R = texture2D(uPressure, vR).x;\n                    float T = texture2D(uPressure, vT).x;\n                    float B = texture2D(uPressure, vB).x;\n                    float C = texture2D(uPressure, vUv).x;\n                    float divergence = texture2D(uDivergence, vUv).x;\n                    float pressure = (L + R + B + T - divergence) * 0.25;\n                    gl_FragColor = vec4(pressure, 0.0, 0.0, 1.0);\n                }\n            ",gradientSubtractShader:()=>"\n                precision mediump float;\n                precision mediump sampler2D;\n\n                varying highp vec2 vUv;\n                varying highp vec2 vL;\n                varying highp vec2 vR;\n                varying highp vec2 vT;\n                varying highp vec2 vB;\n                uniform sampler2D uPressure;\n                uniform sampler2D uVelocity;\n\n                void main () {\n                    float L = texture2D(uPressure, vL).x;\n                    float R = texture2D(uPressure, vR).x;\n                    float T = texture2D(uPressure, vT).x;\n                    float B = texture2D(uPressure, vB).x;\n                    vec2 velocity = texture2D(uVelocity, vUv).xy;\n                    velocity.xy -= vec2(R - L, T - B);\n                    gl_FragColor = vec4(velocity, 0.0, 1.0);\n                }\n            ",advectionVertexShader:()=>"\n                precision highp float;\n\n                attribute vec2 aPosition;\n                varying vec2 vUv;\n                varying vec2 vL;\n                varying vec2 vR;\n                varying vec2 vT;\n                varying vec2 vB;\n                uniform vec2 texelSize;\n\n                void main () {\n                    vUv = aPosition * 0.5 + 0.5;\n                    vL = vUv - vec2(texelSize.x, 0.0);\n                    vR = vUv + vec2(texelSize.x, 0.0);\n                    vT = vUv + vec2(0.0, texelSize.y);\n                    vB = vUv - vec2(0.0, texelSize.y);\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n                }\n            ",divergenceVertexShader:()=>"\n                precision highp float;\n\n                attribute vec2 aPosition;\n                varying vec2 vUv;\n                varying vec2 vL;\n                varying vec2 vR;\n                varying vec2 vT;\n                varying vec2 vB;\n                uniform vec2 texelSize;\n\n                void main () {\n                    vUv = aPosition * 0.5 + 0.5;\n                    vL = vUv - vec2(texelSize.x, 0.0);\n                    vR = vUv + vec2(texelSize.x, 0.0);\n                    vT = vUv + vec2(0.0, texelSize.y);\n                    vB = vUv - vec2(0.0, texelSize.y);\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n                }\n            ",curlVertexShader:()=>"\n                precision highp float;\n\n                attribute vec2 aPosition;\n                varying vec2 vUv;\n                varying vec2 vL;\n                varying vec2 vR;\n                varying vec2 vT;\n                varying vec2 vB;\n                uniform vec2 texelSize;\n\n                void main () {\n                    vUv = aPosition * 0.5 + 0.5;\n                    vL = vUv - vec2(texelSize.x, 0.0);\n                    vR = vUv + vec2(texelSize.x, 0.0);\n                    vT = vUv + vec2(0.0, texelSize.y);\n                    vB = vUv - vec2(0.0, texelSize.y);\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n                }\n            ",vorticityVertexShader:()=>"\n                precision highp float;\n\n                attribute vec2 aPosition;\n                varying vec2 vUv;\n                varying vec2 vL;\n                varying vec2 vR;\n                varying vec2 vT;\n                varying vec2 vB;\n                uniform vec2 texelSize;\n\n                void main () {\n                    vUv = aPosition * 0.5 + 0.5;\n                    vL = vUv - vec2(texelSize.x, 0.0);\n                    vR = vUv + vec2(texelSize.x, 0.0);\n                    vT = vUv + vec2(0.0, texelSize.y);\n                    vB = vUv - vec2(0.0, texelSize.y);\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n                }\n            ",pressureVertexShader:()=>"\n                precision highp float;\n\n                attribute vec2 aPosition;\n                varying vec2 vUv;\n                varying vec2 vL;\n                varying vec2 vR;\n                varying vec2 vT;\n                varying vec2 vB;\n                uniform vec2 texelSize;\n\n                void main () {\n                    vUv = aPosition * 0.5 + 0.5;\n                    vL = vUv - vec2(texelSize.x, 0.0);\n                    vR = vUv + vec2(texelSize.x, 0.0);\n                    vT = vUv + vec2(0.0, texelSize.y);\n                    vB = vUv - vec2(0.0, texelSize.y);\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n                }\n            ",gradienSubtractVertexShader:()=>"\n                precision highp float;\n\n                attribute vec2 aPosition;\n                varying vec2 vUv;\n                varying vec2 vL;\n                varying vec2 vR;\n                varying vec2 vT;\n                varying vec2 vB;\n                uniform vec2 texelSize;\n\n                void main () {\n                    vUv = aPosition * 0.5 + 0.5;\n                    vL = vUv - vec2(texelSize.x, 0.0);\n                    vR = vUv + vec2(texelSize.x, 0.0);\n                    vT = vUv + vec2(0.0, texelSize.y);\n                    vB = vUv - vec2(0.0, texelSize.y);\n                    gl_Position = vec4(aPosition, 0.0, 1.0);\n                }\n            "},createShaders:e=>{let n=e.gl,i=e.ext,r=e.settings;e.baseVertexShader=SR7.A.fluiddynamics.compileShader(n.VERTEX_SHADER,SR7.A.fluiddynamics.shaders.baseVertexShader(),n),e.copyShader=SR7.A.fluiddynamics.compileShader(n.FRAGMENT_SHADER,SR7.A.fluiddynamics.shaders.copyShader(),n),e.clearShader=SR7.A.fluiddynamics.compileShader(n.FRAGMENT_SHADER,SR7.A.fluiddynamics.shaders.clearShader(),n),e.finalShader=SR7.A.fluiddynamics.compileShader(n.FRAGMENT_SHADER,SR7.A.fluiddynamics.shaders.finalShader(),n),e.displayShaderSource=SR7.A.fluiddynamics.compileShader(n.FRAGMENT_SHADER,SR7.A.fluiddynamics.shaders.displayShaderSource(r),n),e.splatShader=SR7.A.fluiddynamics.compileShader(n.FRAGMENT_SHADER,SR7.A.fluiddynamics.shaders.splatShader(r),n),e.splatShader2=SR7.A.fluiddynamics.compileShader(n.FRAGMENT_SHADER,SR7.A.fluiddynamics.shaders.splatShader2(r),n),e.advectionShader=SR7.A.fluiddynamics.compileShader(n.FRAGMENT_SHADER,SR7.A.fluiddynamics.shaders.advectionShader(),n,i.supportLinearFiltering?null:["MANUAL_FILTERING"]),e.divergenceShader=SR7.A.fluiddynamics.compileShader(n.FRAGMENT_SHADER,SR7.A.fluiddynamics.shaders.divergenceShader(),n),e.curlShader=SR7.A.fluiddynamics.compileShader(n.FRAGMENT_SHADER,SR7.A.fluiddynamics.shaders.curlShader(),n),e.vorticityShader=SR7.A.fluiddynamics.compileShader(n.FRAGMENT_SHADER,SR7.A.fluiddynamics.shaders.vorticityShader(),n),e.pressureShader=SR7.A.fluiddynamics.compileShader(n.FRAGMENT_SHADER,SR7.A.fluiddynamics.shaders.pressureShader(),n),e.gradientSubtractShader=SR7.A.fluiddynamics.compileShader(n.FRAGMENT_SHADER,SR7.A.fluiddynamics.shaders.gradientSubtractShader(),n),r.isFirefox&&(e.advectionVertexShader=SR7.A.fluiddynamics.compileShader(n.VERTEX_SHADER,SR7.A.fluiddynamics.shaders.advectionVertexShader(),n),e.divergenceVertexShader=SR7.A.fluiddynamics.compileShader(n.VERTEX_SHADER,SR7.A.fluiddynamics.shaders.divergenceVertexShader(),n),e.curlVertexShader=SR7.A.fluiddynamics.compileShader(n.VERTEX_SHADER,SR7.A.fluiddynamics.shaders.curlVertexShader(),n),e.vorticityVertexShader=SR7.A.fluiddynamics.compileShader(n.VERTEX_SHADER,SR7.A.fluiddynamics.shaders.vorticityVertexShader(),n),e.pressureVertexShader=SR7.A.fluiddynamics.compileShader(n.VERTEX_SHADER,SR7.A.fluiddynamics.shaders.pressureVertexShader(),n),e.gradienSubtractVertexShader=SR7.A.fluiddynamics.compileShader(n.VERTEX_SHADER,SR7.A.fluiddynamics.shaders.gradienSubtractVertexShader(),n))},compileShader:(e,n,i,r)=>{n=SR7.A.fluiddynamics.addKeywords(n,r);const t=i.createShader(e);return i.shaderSource(t,n),i.compileShader(t),i.getShaderParameter(t,i.COMPILE_STATUS)||console.trace(i.getShaderInfoLog(t)),t},addKeywords:(e,n)=>{if(null==n)return e;let i="";return n.forEach((e=>{i+="#define "+e+"\n"})),i+e}},_tpt.R??={},_tpt.R.fd_Shaders=_tpt.extend?_tpt.extend(_tpt.R.fd_Shaders,{status:2,version:"1.0"}):{status:2,version:"1.0"},window.dispatchEvent(new CustomEvent("SR7FluiddynamicsShadersLoaded")))}();
!function(){"use strict";window.SR7??={},window._tpt??={},SR7.A??={},SR7.F??={},SR7.D??={},void 0===(SR7.A.fluiddynamics?.tools??void 0)&&(SR7.A.fluiddynamics={...SR7.A.fluiddynamics,tools:{resetMaxOpacity:(t,s)=>{t[0]*=s,t[1]*=s,t[2]*=s,t[3]>s&&(t[3]=s)},getRGBA:t=>{if("string"!=typeof t)throw"Passed color was not a String";if(t.includes("#")){t=tpGS.gsap.utils.splitColor(t);for(let s=0;s<t.length;s++)t[s]/=255;t.push(1)}if(t.includes("rgba")){t=tpGS.gsap.utils.splitColor(t);for(let s=0;s<t.length-1;s++)t[s]/=255;t.length<=3&&(t[3]=1)}return t}}},_tpt.R??={},_tpt.R.fd_Tools=_tpt.extend?_tpt.extend(_tpt.R.fd_Tools,{status:2,version:"1.0"}):{status:2,version:"1.0"},window.dispatchEvent(new CustomEvent("SR7FluidDynamicsToolsLoaded")))}();